<!DOCTYPE html><html lang="en" data-theme="light"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content=""><meta name="author" content=""><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/blog/rss.xml" /><meta property="og:title" content="Specifications &gt;&gt; The Sesame Algorithm: Session Management for Asynchronous Message Encryption" /><meta property="og:site_name" content="Signal Messenger" /><meta property="og:type" content="website" /><meta property="og:description" content="This document describes the Sesame algorithm for managing message encryption sessions in an asynchronous and multi-device setting." /><meta property="og:url" content="https://signal.org/docs/specifications/sesame/" /><meta property="og:image" content="https://signal.org/assets/images/og/og-image.png" /><meta property="og:image:width" content="1200" /><meta property="og:image:height" content="630" /><meta name="twitter:site" content="@signalapp"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@signalapp"><meta name="twitter:url" content="https://signal.org/docs/specifications/sesame/"><meta name="twitter:title" content="Specifications &gt;&gt; The Sesame Algorithm: Session Management for Asynchronous Message Encryption"><meta name="twitter:description" content="This document describes the Sesame algorithm for managing message encryption sessions in an asynchronous and multi-device setting."><title>Signal >> Specifications &gt;&gt; The Sesame Algorithm: Session Management for Asynchronous Message Encryption</title><link rel="me" href="https://mastodon.world/@signalapp"><link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/svg+xml" href="/assets/images/favicon/favicon.svg"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png"><link rel="manifest" href="/assets/images/favicon/site.webmanifest"><link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#3b45fd"><meta name="msapplication-TileColor" content="#e3e8fe"><meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml"><meta name="theme-color" content="#e3e8fe"><link rel="preload" href="/assets/fonts/inter/Inter-Regular.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="/assets/fonts/inter/Inter-ExtraBold.woff2" as="font" crossorigin="anonymous"><link type="text/css" rel="stylesheet" href="/assets/stylesheets/vendor/bulma-1.0.4.min.css"><link type="text/css" rel="stylesheet" href="/assets/stylesheets/ultramarine.css"><body id="signal" class="index has-navbar-fixed-top"><nav class="navbar signal-navbar is-fixed-top" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a href="/#signal"> <img class="signal-logo" src="/assets/images/header/logo.png"/> </a> <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="signalNavbar"> <span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span> </a></div><div id="signalNavbar" class="navbar-menu"><div class="navbar-end"> <a class="navbar-item get-signal" href="/download/">Get Signal</a> <a class="navbar-item" href="https://support.signal.org">Help</a> <a class="navbar-item" href="/blog/">Blog</a> <a class="navbar-item" href="/docs/">Developers</a> <a class="navbar-item" href="/workworkwork/">Careers</a> <a class="navbar-item" href="/donate/">Donate</a></div></div></div></nav><section id="specification" class="post"><article><div class="container content"><div class="columns is-centered"><div class="column is-8"> <img class="author" src="/assets/images/body/spaceship.png" style="margin-top: 0" /><h1 class="title text-center"> The Sesame Algorithm: Session Management for Asynchronous Message Encryption</h1><h3 class="subtitle"><p>Revision 2, 2017-04-14 [<a href="sesame.pdf">PDF</a>]<p>Moxie Marlinspike, Trevor Perrin (editor)</h3></div></div><div class="columns is-centered"><div class="column is-8"><div id="TOC"><h2 class="toc">Table of Contents</h2><ul><li><a href="#introduction">1. Introduction</a><li><a href="#preliminaries">2. Preliminaries</a><ul><li><a href="#overview">2.1. Overview</a><li><a href="#assumptions">2.2. Assumptions</a></ul><li><a href="#sesame">3. Sesame</a><ul><li><a href="#device-state">3.1. Device state</a><li><a href="#updating-device-state">3.2. Updating device state</a><li><a href="#sending-messages">3.3. Sending messages</a><li><a href="#receiving-messages">3.4. Receiving messages</a></ul><li><a href="#optional-features">4. Optional features</a><ul><li><a href="#retry-requests-and-delivery-receipts">4.1. Retry requests and delivery receipts</a><li><a href="#session-expiration">4.2. Session expiration</a></ul><li><a href="#implementation-considerations">5. Implementation considerations</a><ul><li><a href="#server">5.1. Server</a><li><a href="#x3dh-and-the-double-ratchet">5.2. X3DH and the Double Ratchet</a></ul><li><a href="#security-considerations">6. Security considerations</a><ul><li><a href="#authentication">6.1. Authentication</a><li><a href="#device-compromise">6.2. Device compromise</a><li><a href="#protecting-server-communications">6.3. Protecting server communications</a><li><a href="#deleting-old-data">6.4. Deleting old data</a><li><a href="#bounded-loops-and-bounded-storage">6.5. Bounded loops and bounded storage</a><li><a href="#error-handling">6.7. Error handling</a></ul><li><a href="#ipr">7. IPR</a><li><a href="#acknowledgements">8. Acknowledgements</a><li><a href="#references">9. References</a></ul></div><p><h1 id="introduction">1. Introduction</h1><p>This document describes the Sesame algorithm for managing message encryption sessions in an asynchronous and multi-device setting.<p>Sesame was designed to manage Double Ratchet sessions created with X3DH key agreement <span class="citation">[<a href="#ref-x3dh">1</a>], [<a href="#ref-doubleratchet">2</a>]</span>. However, Sesame is a generic algorithm that works with any session-based message encryption algorithm that meets certain conditions.<h1 id="preliminaries">2. Preliminaries</h1><h2 id="overview">2.1. Overview</h2><p>Asynchronous key agreement protocols like X3DH enable one party to create a message encryption session and use that session to encrypt an initial message to a recipient, even if the recipient is offline <span class="citation">[<a href="#ref-x3dh">1</a>]</span>. The recipient can later retrieve the message and use it to calculate a matching session which is used to decrypt the message.<p>Ratcheting algorithms like the Double Ratchet allow these two parties to update session keys as they communicate, for forward secrecy <span class="citation">[<a href="#ref-doubleratchet">2</a>]</span>.<p>Combining these algorithms in a practical context introduces some new concerns:<ul><li><p>Alice and Bob might each have several devices, so encrypting a message from Alice to Bob might require creating sessions from Alice's sending device to all of Bob's devices, and also to Alice's other devices (so they receive a copy of the message).<li><p>Alice and Bob might add and remove devices, so they will have to add and delete sessions to handle these changes.<li><p>Alice and Bob might simultaneously initiate a new session with each other, so that two new sessions are created. For the Double Ratchet to be maximally effective Alice and Bob must send and receive messages using matching sessions, so somehow they must agree on which matching sessions to use.<li><p>Alice might choose to erase her device's session state, or restore from a backup, thus causing either her or Bob to possess orphaned sessions which no longer match one of the other party's sessions.</ul><p>Any solutions to the above must consider that messages might be lost or arrive out-of-order, that clock synchronization is not reliable, and that attackers might compromise devices and/or interfere with communication.<p>The Sesame algorithm manages the creation, deletion, and use of sessions to support these requirements. A central idea is for each device to keep track of an &quot;active&quot; session for each other device it is communicating with, and use the active session when sending to that device. When a message is received on an &quot;inactive&quot; session, that becomes the new active session. By this process each device converges on using a single session for each remote device it communicates with.<h2 id="assumptions">2.2. Assumptions</h2><p>Sesame is based on the following assumptions:<p><strong>Server</strong><ul><li><p>There is a server which stores the current record of all users and devices.<li><p>The server temporarily stores the messages that devices send to each other, until the messages are fetched.</ul><p><strong>Users</strong><ul><li><p>At any point in time there is a set of users.<li><p>Users might be added or deleted at any time.<li><p>Each user has a <strong><em>UserID</em></strong> (e.g. a username or phone number).<li><p>After a user is deleted, its <em>UserID</em> can be taken by a new user.</ul><p><strong>Devices</strong><ul><li><p>At any point in time each user has a nonempty set of devices.<li><p>Users can add or delete devices at any time.<li><p>Each device has a <strong><em>DeviceID</em></strong> which is unique for the <em>UserID</em>.<li><p>Devices can ask the server for information about other users and devices.<li><p>Devices can maintain state, but at any point in time this state might be deleted in whole or part (e.g. by hardware failure or a user action), or rolled back to an earlier state (e.g. by restoring a backup).<li><p>Devices have clocks that can measure elapsed time, but are not synchronized.</ul><p><strong>Mailboxes</strong><ul><li><p>The server stores a mailbox for each device.<li><p>A mailbox holds a set of messages that were sent to the device.<li><p>Messages are removed from the mailbox when fetched.<li><p>Devices can send messages to other devices' mailboxes. The server stores the sending device's <em>UserID</em> and <em>DeviceID</em> alongside the message.<li><p>Devices can fetch messages from their own mailbox. The recipient device fetches the message and the sender's <em>UserID</em> and <em>DeviceID</em> from the server.<li><p>Messages sent to a mailbox are unreliable in normal operation - they may be corrupted, deleted, reordered, delayed, or duplicated before arriving at the mailbox.<li><p>In normal operation, a message that hasn't arrived at a mailbox within some time interval (<strong><em>MAXLATENCY</em></strong>) has been lost.<li><p>Messages sent to a mailbox might be subject to adversary actions - an attacker (including the server) might corrupt, delete, reorder, duplicate, or forge messages before they arrive at the mailbox.</ul><p><strong>Sessions</strong><ul><li><p>Messages can be encrypted and decrypted using a session, which is some secret data stored by a device.<li><p>Decrypting a message might fail (e.g. if the ciphertext has been tampered with or forged, and thus fails an authentication check).<li><p>An encrypted message can only be decrypted using a <strong>matching session</strong>.<li><p>There is some <strong><em>SessionID</em></strong> which uniquely identifies each session.<li><p>A session might contain different data after encrypting or decrypting a message (e.g. keys might be deleted after they are used, for forward secrecy).</ul><p><strong>Session creation for senders</strong><ul><li><p>Each device has an <strong>identity key pair</strong> consisting of a <strong>public key</strong> and <strong>private key</strong>.<li><p>A device can create a new <strong>initiating session</strong> at any time.<li><p>Creating an initiating session requires specifying the identity public key for the intended recipient device which will receive the matching session.<li><p>Creating a new session might fail (e.g. the sending device may have to fetch and cryptographically authenticate parameters associated with the recipient device, such as <strong>prekeys</strong> <span class="citation">[<a href="#ref-x3dh">1</a>]</span>).</ul><p><strong>Session creation for recipients</strong><ul><li><p>All messages encrypted by an initiating session are <strong>initiation messages</strong>.<li><p>All initiation messages contain the sending device's identity public key in an unencrypted header.<li><p>Upon receiving an initiation message, the intended recipient device can create a matching session which is used to decrypt the initiation message.<li><p>Creating a matching session may fail (e.g. if cryptographic authentication of the initiation message fails).<li><p>Upon decrypting a message for the first time, an initiating session becomes a regular (non-initiating) session, and thus stops producing initiation messages.</ul><h1 id="sesame">3. Sesame</h1><p>The Sesame algorithm defines the state that each device stores, and the algorithms that use this state to send and receive encrypted messages.<h2 id="device-state">3.1. Device state</h2><p>Each device stores a set of <strong><em>UserRecords</em></strong> for its correspondents, indexed by <em>UserID</em>.<p>Each <em>UserRecord</em> contains a set of <strong><em>DeviceRecords</em></strong>, indexed by <em>DeviceID</em>.<p>Each <em>DeviceRecord</em> may contain an <strong>active session</strong> and/or an ordered list of <strong>inactive sessions</strong>.<p>Each device stores a <em>UserRecord</em> for its own <em>UserID</em>, but does not store a <em>DeviceRecord</em> for its own <em>DeviceID</em>. This <em>UserRecord</em> enables a device to send a copy of each outbound message to the user's other devices.<p>A <em>UserRecord</em> or <em>DeviceRecord</em> might be marked <strong>stale</strong>, meaning the record corresponds to a deleted user or device but is being kept around to decrypt delayed messages.<p>A stale record may be deleted by the sending device at any time (including immediately upon being marked stale). To handle delayed messages, the recommended deletion policy is for a stale record to contain a timestamp recording when it was first marked stale. Once the timestamp is older than <em>MAXLATENCY</em>, the stale record can be safely deleted (without fear of message loss) after the next time the device fetches and processes all messages from its mailbox.<p>Each device stores an <strong>identity key pair</strong> (a public key and private key) for cryptographic authentication. A device will always have the same <em>DeviceID</em> and identity key pair (to change these for some physical device the device must be logically deleted and then added with new values).<p>Sesame supports two different models for key pairs: With <strong>per-user identity keys</strong>, all devices under a user share the same key pair. With <strong>per-device identity keys</strong>, each device may have a different key pair.<p>With per-user identity keys, identity public keys for other devices are stored in <em>UserRecords</em>. With per-device identity keys, identity public keys for other devices are stored in <em>DeviceRecords</em>.<h2 id="updating-device-state">3.2. Updating device state</h2><p>Devices can modify their local state in several ways:<p>Devices can <strong>delete</strong> <em>UserRecords</em>, <em>DeviceRecords</em>, and sessions. If the last session in a <em>DeviceRecord</em> is deleted, then the <em>DeviceRecord</em> is deleted. If the last <em>DeviceRecord</em> in a <em>UserRecord</em> is deleted, then the <em>UserRecord</em> is deleted.<p>Devices can <strong>insert</strong> new sessions into a <em>DeviceRecord</em>. An inserted session always becomes the <em>DeviceRecord's</em> active session, and the previously active session (if any) is moved to the head of the <em>DeviceRecord's</em> inactive sessions list. If the inactive sessions list grows too large, sessions may be deleted from the tail end.<p>Devices can <strong>activate</strong> an inactive session in a <em>DeviceRecord</em>, which moves the inactive session to the <em>DeviceRecord's</em> active session, and moves the previously active session (if any) to the head of the <em>DeviceRecord's</em> inactive sessions list.<p>Devices can <strong>mark</strong> <em>UserRecords</em> or <em>DeviceRecords</em> as stale.<p>Devices can <strong>conditionally update</strong> their records based on a (<em>UserID</em>, <em>DeviceID</em>, public key) tuple:<ol style="list-style-type: decimal"><li><p>If a relevant <em>UserRecord</em> does not exist or stores an identity public key that doesn't equal the input public key, then an empty <em>UserRecord</em> is added for this <em>UserID</em> (replacing the previous <em>UserRecord</em> if one exists). With per-user identity public keys, the input public key is stored in the empty record.<li><p>If a relevant <em>DeviceRecord</em> does not exist or stores an identity public key that doesn't equal the input public key, then an empty <em>DeviceRecord</em> is added for this <em>DeviceID</em> (replacing the previous <em>DeviceRecord</em> if one exists). With per-device identity public keys, the input public key is stored in the empty record. If the <em>UserID</em> and <em>DeviceID</em> equal the device's own values, then a <em>DeviceRecord</em> is not added (a device doesn't add a <em>DeviceRecord</em> for itself).</ol><p>Devices can <strong>prep for encrypting</strong> to a (<em>UserID</em>, <em>DeviceID</em>, public key) tuple:<ol style="list-style-type: decimal"><li><p>The device deletes the relevant <em>UserRecord</em> and/or <em>DeviceRecord</em> if they are stale.<li><p>The device conditionally updates its records based on the tuple.<li><p>If the relevant <em>DeviceRecord</em> doesn't have an active session, then the device creates a new initiating session using the relevant public key for the <em>DeviceRecord</em>. The new session is inserted into the <em>DeviceRecord</em>.</ol><h2 id="sending-messages">3.3. Sending messages</h2><p>The input to the Sesame sending process is some plaintext and a set of recipient <em>UserIDs</em>. The recipient set includes the device's own <em>UserID</em>.<p>The plaintext is encrypted and sent by the sending device using the following process for each recipient <em>UserID</em>:<ol style="list-style-type: decimal"><li><p>If a relevant non-stale <em>UserRecord</em> exists for the recipient <em>UserID</em>, then for each non-stale <em>DeviceRecord</em> in the <em>UserRecord</em> that contains an active session, the sending device encrypts the plaintext using that active session.<li><p>The recipient <em>UserID</em> is sent to the server, along with the list of encrypted messages and a corresponding list of <em>DeviceIDs</em> indicating the recipient mailbox for each message. These lists will be empty if no relevant active sessions exist.<li><p>If the recipient <em>UserID</em> is currently in-use and the sender's list of <em>DeviceIDs</em> is current for the recipient <em>UserID</em>, then the server accepts the messages and the messages are sent to the relevant mailboxes. This process then terminates for the recipient <em>UserID</em>, returning to step 1 for the next recipient <em>UserID</em>.<li><p>Otherwise the server rejects the messages and either informs the sending device if the recipient <em>UserID</em> does not exist; or informs the sending device of the old <em>DeviceIDs</em> and new <em>DeviceIDs</em> needed to make the sending device's records current, and the identity public keys corresponding to any new <em>DeviceIDs</em>.<li><p>If the server indicates that the recipient <em>UserID</em> does not exist, then the sending device marks the relevant <em>UserRecord</em> (if any) as stale. The sending device then terminates this process for the recipient <em>UserID</em>, returning to step 1 for the next recipient <em>UserID</em>.<li><p>For each old <em>DeviceID</em>, the sending device marks the relevant <em>DeviceRecord</em> as stale.<li><p>For each new <em>DeviceID</em>, the sending device preps for encrypting to the tuple (<em>UserID</em>, <em>DeviceID</em>, relevant public key).<li><p>This process is restarted from step 1 for the current recipient <em>UserID</em>.</ol><p>If any error occurs in encrypting to a particular user (e.g. an invalid server response, or a failure during session creation), then the sending device shall discard any changes to the relevant <em>UserRecord</em>. This avoids leaving records in an inconsistent state. The sending device may choose to continue encrypting and sending to other users, or may terminate the entire sending process.<p>To avoid excessive looping in case of a malicious or buggy server, devices should impose some limit on the number of times they're willing to repeat the message sending loop for a recipient user.<h2 id="receiving-messages">3.4. Receiving messages</h2><p>The input to the Sesame receiving process is an encrypted message and the sender's <em>UserID</em> and <em>DeviceID</em>, all of which were fetched from the server.<p>How the message is fetched is out of scope for this document. Devices might periodically poll the server, or they might receive some notification when new messages are available to be fetched.<p>An encrypted message is decrypted by a recipient device using the following process:<ol style="list-style-type: decimal"><li><p>If the encrypted message is an initiation message and the recipient device does not have a relevant <em>DeviceRecord</em> containing a session that can decrypt the message, then the following steps are performed:<ol style="list-style-type: lower-alpha"><li><p>The relevant public key is extracted from the message header.<li><p>The device conditionally updates its records based on the (sender's <em>UserID</em>, sender's <em>DeviceID</em>, relevant public key) tuple.<li><p>The device creates a new session using the initiating message and inserts the new session into the relevant <em>DeviceRecord</em>.</ol><li><p>If no session in the relevant <em>DeviceRecord</em> can decrypt the encrypted message, then the encrypted message is discarded, all changes to device state are discarded, and this process terminates.<li><p>Otherwise, the message is decrypted with the relevant session.<li><p>If the relevant session is not active it is activated.</ol><p>If any error occurs in parsing or processing the message, including cryptographic errors in session creation or decrypting the message, then the device shall discard all state changes, discard the encrypted message, and terminate the decryption process.<h1 id="optional-features">4. Optional features</h1><h2 id="retry-requests-and-delivery-receipts">4.1. Retry requests and delivery receipts</h2><p>If the sender or recipient device's state has been rolled back, or the recipient device's state has been deleted, then it is possible for the recipient device to receive a valid message that it can't decrypt.<p>To handle this without message loss the sending device may store a set of <strong><em>MessageRecords</em></strong>, indexed by some <strong><em>MessageID</em></strong> which is unique for each encrypted message. If a single message is encrypted to several recipient devices the sender will store a separate <em>MessageRecord</em> for each recipient device, each with a unique <em>MessageID</em>. Each <em>MessageRecord</em> stores the following values:<ul><li>The plaintext of the encrypted message.<li>The <em>UserID</em> for the recipient device.<li>The <em>SessionID</em> for the session the message was encrypted with.</ul><p>When the recipient device receives an undecryptable message, the recipient device sends an unencrypted <strong>retry request</strong> message to the original sending device's mailbox, containing the undecryptable message's <em>MessageID</em>.<p>When the original sending device fetches a retry request along with the relevant <em>UserID</em> and <em>DeviceID</em> of the device that sent the retry request, the original sending device executes the following <strong>resending</strong> process:<ol style="list-style-type: decimal"><li><p>If the <em>MessageID</em> doesn't refer to a current <em>MessageRecord</em>, then the retry request is discarded and this process terminates.<li><p>If the relevant <em>MessageRecord</em> doesn't contain a <em>UserID</em> that equals the <em>UserID</em> used to send the retry request, then the retry request is discarded and this process terminates. (Note that there is no similar check for <em>DeviceID</em>; for flexibility, the retry request is allowed from a different <em>DeviceID</em> than was originally sent to.)<li><p>If a non-stale <em>UserRecord</em> and non-stale <em>DeviceRecord</em> with an active session do not exist for the relevant <em>UserID</em> and <em>DeviceID</em>; or if such a session does exist but it matches the <em>SessionID</em> from the relevant <em>MessageRecord</em>, then:<ol style="list-style-type: lower-alpha"><li><p>The resending device queries the server for the identity public key corresponding to the relevant <em>UserID</em> and <em>DeviceID</em>.<li><p>If the server indicates that the recipient <em>UserID</em> or <em>DeviceID</em> do not exist, then the relevant records are marked stale, the retry request is discarded, and this process terminates.<li><p>The sender then preps for encrypting to the tuple (<em>UserID</em>, <em>DeviceID</em>, public key).<li><p>If the <em>DeviceRecord's</em> active session matches the <em>SessionID</em> from the relevant <em>MessageRecord</em>, then the sending device creates a new initiating session using the relevant public key for the <em>DeviceRecord</em>. The new session is inserted into the <em>DeviceRecord</em>. This prevents the sending device from repeatedly sending a message using an orphaned session which doesn’t match any recipient session.</ol><li><p>The resending device encrypts the plaintext from the <em>MessageRecord</em> using the active session from the relevant <em>DeviceRecord</em>.<li><p>The resending device sends the encrypted message to the server, along with the <em>UserID</em> and <em>DeviceID</em> indicating the recipient mailbox.<li><p>If the server indicates that the recipient <em>UserID</em> or <em>DeviceID</em> do not exist, then the relevant records are marked stale, the retry request is discarded, and this process terminates.<li><p>Otherwise, the server accepts the message and the message is sent to the relevant mailbox. The resending device deletes the old <em>MessageRecord</em> and adds a new <em>MessageRecord</em> for the new encrypted message.</ol><p><em>MessageRecords</em> might be deleted after some time has elapsed, or if the plaintext they refer to has been deleted from the sending device by the user. Devices might also send <strong>delivery receipts</strong> upon successful message decryption. Delivery receipts refer to some <em>MessageID</em> and notify the sender that the <em>MessageRecord</em> may be deleted. Delivery receipts may be encrypted or unencrypted (since they follow every received message, encrypting them doesn't accomplish much).<p>To avoid excessive resending, devices should impose some limit on the number of times they're willing to resend a message. If any other error occurs, then the resending device shall discard any state changes and terminate the process.<h2 id="session-expiration">4.2. Session expiration</h2><p>It may be desirable for devices to periodically replace old sessions with new sessions, for security purposes. One approach is to give each session a timestamp. The timestamp is set to the current time when an initiating session is created. When initiation messages are fetched, the server tells the recipient device the time difference between when the message arrived at the mailbox and the current time. The recipient device sets the timestamp for any initiated session to the current time minus this difference.<p>Time constants <strong><em>MAXSEND</em></strong> and <strong><em>MAXRECV</em></strong> are defined, where <em>MAXRECV</em> must be greater than <em>MAXSEND + 2(MAXLATENCY)</em>. At time <em>MAXSEND</em> past its timestamp a session must no longer be used for encryption, and shall be moved to the head of the inactive sessions list if active. Attempts to activate such a session have no effect. At time <em>MAXRECV</em> past a session's timestamp the session may be deleted, after first fetching and processing all mailbox messages.<h1 id="implementation-considerations">5. Implementation considerations</h1><h2 id="server">5.1. Server</h2><p>For simplicity of presentation this document discusses a single server that handles all user and device records, and all messages. In a real system these functions might be distributed across multiple entities.<p>For example, different servers might handle different groups of users. In this case, Alice would send a message to Bob by contacting Bob's server, and Bob would send a message to Alice by contacting Alice's server.<p>For another example, the server(s) that handle user and device records might be separate from the server(s) that handle mailboxes.<p>Other divisions of labor might be possible; analyzing all the possibilities is outside the scope of this document.<h2 id="x3dh-and-the-double-ratchet">5.2. X3DH and the Double Ratchet</h2><p>Sesame was designed for use with Double Ratchet sessions <span class="citation">[<a href="#ref-doubleratchet">2</a>]</span> created via X3DH key agreement <span class="citation">[<a href="#ref-x3dh">1</a>]</span>.<p>In this instantiation, devices will publish <strong>one-time prekeys</strong> and <strong>signed prekeys</strong> to the server, alongside their identity public key.<p>To create an initiating session, a sending device will contact the server and fetch a <strong>prekey bundle</strong> containing the recipient device's identity public key, signed prekey, and a one-time prekey (if one is available). These values will be used by the X3DH algorithm to create both a secret key that initializes a Double Ratchet session, and an X3DH initial message.<p>The X3DH initial message is attached to every initiation message, so that the recipient can use it to create a matching Double Ratchet session. Once a response to an initiation message is received, the original sender ceases attaching the X3DH initial message to future messages, so the devices henceforth communicate using only the Double Ratchet.<h1 id="security-considerations">6. Security considerations</h1><h2 id="authentication">6.1. Authentication</h2><p>Sesame relies on users to authenticate identity public keys with their correspondents. For example, a pair of users might compare public key fingerprints for all their devices manually, or by scanning a QR code. The details of authentication methods are outside the scope of this document.<p>If authentication is not performed, users receive no cryptographic guarantee as to who they are communicating with.<p>A Sesame device might encounter a changed identity public key (or keys) for some remote user when sending, receiving, or resending messages.<p>This might indicate that a new user is using the <em>UserID</em>, that the user re-installed the application, or that the user added new devices (if per-device identity keys are being used). It might also indicate an attempt to impersonate the remote user by a malicious server, or by a malicious user who hijacked the original user's <em>UserID</em>.<p>Whenever a change in identity keys is detected users must repeat the authentication process or they will receive no cryptographic guarantee as to who they are communicating with. A device may wish to pause (or abort) the sending, receiving, or resending processes if a key change occurs, and only continue (or restart) the process if the user affirmatively acknowledges the key change. In this case, the conditional update operation will pause (or generate an error) on detecting a key change.<h2 id="device-compromise">6.2. Device compromise</h2><p>Security is catastrophically compromised if an attacker learns a device's secret values, such as the identity private key and session state. Recovery from a device compromise requires the user to replace the compromised device and compromised identity key pair and notify all correspondents of the new public key.<p>An attacker can leverage a compromise in many ways:<ul><li><p>An attacker with a device's identity private key can impersonate the compromised device to other devices.<li><p>An attacker who can compromise a device may be able to keep persistent backdoor access to the device, or tamper with it to reduce its future security (e.g. weakening the random number generator).<li><p>An attacker who can steal a device's secret keys can probably also steal the plaintext of locally archived messages, and any plaintext in <em>MessageRecords</em>.<li><p>An attacker might try to use compromised keys for <strong>passive decryption</strong>. For example, the attacker might try to retroactively decrypt old communications, or stealthily decrypt future communications. The attacker might also use some cryptanalytic or forensic attack to reveal a device's state at some time in the past, then try to use this state to decrypt as much old traffic as possible.<p>Sesame's resistance to passive decryption is inherited from the session creation and message encryption algorithms it is instantiated with. For example, when Sesame uses X3DH and the Double Ratchet Algorithm, passive decryption of pre-compromise and post-compromise messages is tightly bounded by the use of ephemeral keys, prekeys, and ratcheting (<span class="citation">[<a href="#ref-x3dh">1</a>], [<a href="#ref-doubleratchet">2</a>]</span>).<p>The only caveat occurs when security is improved by message exchange with matching sessions, as in the Diffie-Hellman ratchet <span class="citation">[<a href="#ref-doubleratchet">2</a>]</span>. In that case, and in the rare instance that two parties simultaneously initiate new sessions with each other, then it may take a few exchanged messages before Sesame converges on a single pair of matching sessions.<li><p>Prior to compromising the target device, an attacker might manipulate communications so as to increase the attacker's ability to decrypt older messages once the compromise occurs. For example, the server could make each message received by the target device use a new X3DH initial message without a one-time prekey (by forging retry requests, or by repeatedly deleting and re-adding devices). In this case, messages sent to the target during the lifetime of a signed prekey's private key would be decryptable if the attacker compromises that private key.<li><p>An attacker might try to perform <strong>key-compromise impersonation</strong>, where the attacker impersonates other parties to the compromised party (which is different than impersonating the compromised party to other parties). For example, when Sesame uses X3DH and the Double Ratchet, the server can use a compromised signed prekey with X3DH to create sessions with the target that appear to match arbitrary third parties. This attacker capability would continue until the target deletes their compromised signed prekey private key(s). Following this, the attacker could continue impersonating specific third parties to the target using any sessions the attacker had possession of prior to signed prekey deletion. This attacker capability would continue unless (and until) the target deletes the attacker-controlled sessions through some means such as session expiration.</ul><p>To mitigate the last two points, Sesame devices using X3DH and the Double Ratchet, or similar algorithms, should delete their signed prekeys on a regular basis, without allowing a malicious server to inhibit deletion. Session expiration (<a href="#session-expiration">Section 4.2</a>) would help mitigate the final point.<p>Despite the various mitigations, none of these threats can be eliminated completely. None of the mitigations change the catastrophic nature of a device compromise, or the necessity of completely replacing a compromised device and any compromised keys.<h2 id="protecting-server-communications">6.3. Protecting server communications</h2><p>Communication between devices and servers should be encrypted and authenticated. This limits the amount of metadata that is exposed to eavesdroppers, and makes it harder for third-party attackers to perform active or passive attacks on device-to-device communications.<p>If an attacker is able to impersonate a victim device when authenticating to the server, the attacker could fetch messages being sent to this device. The attacker would not be able to decrypt these messages, but would learn sender <em>UserIDs</em> and <em>DeviceIDs</em>.<p>This could also occur if the attacker registers with the server using the same <em>UserID</em>, <em>DeviceID</em>, and identity public key that had previously belonged to a victim device. To mitigate this, the server could assign random <em>DeviceIDs</em>, to prevent reuse, or could require the registering user to prove possession of the identity private key (e.g. by signing a nonce during registration).<h2 id="deleting-old-data">6.4. Deleting old data</h2><p>When a user chooses to delete a plaintext message from their device, any <em>MessageRecords</em> containing copies of that plaintext should also be deleted.<p>Sesame uses time thresholds to determine when it is safe to delete older sessions (i.e. stale <em>UserRecords</em> and <em>DeviceRecords</em> as in <a href="#device-state">Section 3.1</a>, and session expiration as in <a href="session-expiration">Section 4.2</a>). The idea is for a recipient to wait for a <em>MAXLATENCY</em> time period after the last messages might have been sent that require the older sessions, at which point these messages have either arrived in the recipient's mailbox or been lost. After the recipient next fetches and processes all mailbox messages, the recipient is assured there are no more outstanding messages that require the older sessions, so the older sessions may be deleted.<p>If clock errors result in the recipient deleting the sessions too early, then there is a risk that undecryptable delayed messages may arrive. If clock errors prevent the recipient's clock from advancing, these older sessions might never be deleted.<p>To mitigate these risks clients should use secure and reliable clocks that cannot be manipulated by an attacker. Clients might also wish to combine time checks with other checks (e.g. counting some number of message round-trips or other events), to provide sanity checks so that brief clock glitches don't delete needed data.<h2 id="bounded-loops-and-bounded-storage">6.5. Bounded loops and bounded storage</h2><p>The message sending loop in <a href="#sending-messages">Section 3.3</a> will repeatedly attempt to adjust the device's records to match the server's records. The resending process in <a href="#retry-requests-and-delivery-receipts">Section 4.1</a> could be repeatedly triggered to resend a message to a recipient.<p>To avoid excessive looping in either case, devices are recommended to use some counter with each process (e.g. stored in memory during sending, and stored in a <em>MessageRecord</em> for resending). Devices would trigger an error after an excessive number of attempts to send, or resend, a message.<p>A device might also be triggered to create an excessive number of <em>DeviceRecords</em> or sessions for some <em>UserID</em>. A device might choose to set some reasonable limit on the number of <em>DeviceRecords</em> it will store for any <em>UserRecord</em>. A device might also choose to set some limit on the number of sessions it will store for any <em>DeviceRecord</em>. Extra sessions will be deleted from the tail of the inactive sessions list if this limit is exceeded.<h2 id="error-handling">6.7. Error handling</h2><p>Care should be taken that any error in sending, receiving, or resending messages terminates the relevant process, and discards any changes that would leave the device in an inconsistent state.<p>Errors in message sending or resending might result in a message being delivered to some but not all of its intended recipient mailboxes.<p>Higher-level protocols built on Sesame must be prepared to handle partial delivery of messages to groups of recipients. One option would be to add transaction semantics so that messages are only committed to mailboxes if sending succeeds for all users, and to mandate support for resending so that messages are likely to be delivered.<h1 id="ipr">7. IPR</h1><p>This document is hereby placed in the public domain.<h1 id="acknowledgements">8. Acknowledgements</h1><p>Thanks to Katriel Cohn-Gordon, Cas Cremers, Luke Garratt, Douglas Stebila, Nik Kinkel, and Tom Ritter for helpful discussions.<p>Thanks to Michael Kirk, Lilia Kai, and Tom Ritter for editorial feedback.<h1 id="references" class="unnumbered">9. References</h1><div id="refs" class="references"><div id="ref-x3dh"><p>[1] M. Marlinspike and T. Perrin, “The X3DH Key Agreement Protocol,” 2016. <a href="https://whispersystems.org/docs/specifications/x3dh/" class="uri">https://whispersystems.org/docs/specifications/x3dh/</a></div><div id="ref-doubleratchet"><p>[2] T. Perrin and M. Marlinspike, “The Double Ratchet Algorithm,” 2016. <a href="https://whispersystems.org/docs/specifications/doubleratchet/" class="uri">https://whispersystems.org/docs/specifications/doubleratchet/</a></div></div></div></div><div class="columns is-centered"><div class="column is-3"></div><div class="column is-6"><h3>Want to get involved with Signal? <a href="/workworkwork/">We're hiring!</a></h3></div><div class="column is-3"></div></div></div></article></section><footer class="footer"><div class="container"><div class="columns"><div class="column is-two-fifths is-hidden-mobile"> <span class="copyright">&copy; 2013&ndash;2026 Signal, a 501c3 nonprofit.</span><br /> "Signal", Signal logos, and other trademarks are trademarks or registered trademarks of Signal Technology Foundation in the United States and other countries (<a href="/brand/">more info here</a>). <br /> <br /> For media inquiries, contact <a href="/cdn-cgi/l/email-protection#a0d0d2c5d3d3e0d3c9c7cec1cc8ecfd2c7"><span class="__cf_email__" data-cfemail="83f3f1e6f0f0c3f0eae4ede2efadecf1e4">[email&#160;protected]</span></a></div><div class="column"> <strong>Organization</strong><ul><li> <a href="/donate/">Donate</a><li> <a href="/workworkwork/">Careers</a><li> <a href="/blog/">Blog</a><li> <a href="/brand/">Brand Assets</a><li> <a href="/legal/">Terms &amp; Privacy Policy</a></ul></div><div class="column"> <strong>Download</strong><ul><li> <a href="/download/android/">Android</a><li> <a href="/download/ios/">iPhone & iPad</a><li> <a href="/download/windows/">Windows</a><li> <a href="/download/macos/">Mac</a><li> <a href="/download/linux/">Linux</a></ul></div><div class="column"> <strong>Social</strong><ul><li> <a href="https://bsky.app/profile/signal.org" target="_blank">Bluesky</a><li> <a href="https://github.com/signalapp" target="_blank">GitHub</a><li> <a href="https://www.instagram.com/signal_app/" target="_blank">Instagram</a><li> <a href="https://mastodon.world/@signalapp" target="_blank">Mastodon</a><li> <a href="https://x.com/signalapp" target="_blank">X</a></ul></div><div class="column"> <strong>Help</strong><ul><li> <a href="https://support.signal.org">Support Center</a><li> <a href="https://community.signalusers.org/">Community</a></ul></div><div class="column is-two-fifths is-hidden-tablet"> <span class="copyright">&copy; 2013&ndash;2026 Signal, a 501c3 nonprofit.</span><br /> "Signal", Signal logos, and other trademarks are trademarks or registered trademarks of Signal Technology Foundation in the United States and other countries (<a href="/brand/">more info here</a>). <br /> <br /> For media inquiries, contact <a href="/cdn-cgi/l/email-protection#65151700161625160c020b04094b0a1702"><span class="__cf_email__" data-cfemail="56262433252516253f3138373a78392431">[email&#160;protected]</span></a></div></div></div></footer><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript" src="/assets/javascripts/vendor/jquery-3.7.1.min.js"></script> <script type="text/javascript" src="/assets/javascripts/vendor/lottie-player-2.0.3.min.js"></script> <script type="text/javascript"> document.addEventListener('DOMContentLoaded', () => { var userAgent = navigator.userAgent.toLowerCase(); var isIOS = ( userAgent.indexOf('iphone') !== -1 || userAgent.indexOf('ipad') !== -1 || userAgent.indexOf('ipod') !== -1 ); var isAndroid = userAgent.indexOf('android') !== -1; var $downloadSignal = $('.get-signal'); if (isIOS || isAndroid) { var url = isIOS ? 'https://apps.apple.com/us/app/signal-private-messenger/id874139669' : 'https://play.google.com/store/apps/details?id=org.thoughtcrime.securesms'; $downloadSignal.prop('href', url); $downloadSignal.html('<span>Get Signal</span> <i class="icon icon-external-link-alt"></i>'); } const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger')); if ($navbarBurgers.length > 0) { $navbarBurgers.forEach((el) => { el.addEventListener('click', () => { const target = el.dataset.target; const $target = document.getElementById(target); el.classList.toggle('is-active'); $target.classList.toggle('is-active'); }); }); } }); </script>
