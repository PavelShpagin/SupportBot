<!DOCTYPE html><html lang="en" data-theme="light"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content=""><meta name="author" content=""><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/blog/rss.xml" /><meta property="og:title" content="Signal Messenger: Speak Freely" /><meta property="og:site_name" content="Signal Messenger" /><meta property="og:type" content="website" /><meta property="og:description" content="Say &quot;hello&quot; to a different messaging experience. An unexpected focus on privacy, combined with all of the features you expect." /><meta property="og:url" content="https://signal.org/docs/specifications/mlkembraid/" /><meta property="og:image" content="https://signal.org/assets/images/og/og-image.png" /><meta property="og:image:width" content="1200" /><meta property="og:image:height" content="630" /><meta name="twitter:site" content="@signalapp"><meta name="twitter:card" content="app"><meta name="twitter:app:name:iphone" content="Signal"><meta name="twitter:app:id:iphone" content="874139669"><meta name="twitter:app:name:googleplay" content="Signal"><meta name="twitter:app:id:googleplay" content="org.thoughtcrime.securesms"><title>Signal >> Specifications &gt;&gt; The ML-KEM Braid Protocol</title><link rel="me" href="https://mastodon.world/@signalapp"><link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/svg+xml" href="/assets/images/favicon/favicon.svg"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png"><link rel="manifest" href="/assets/images/favicon/site.webmanifest"><link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#3b45fd"><meta name="msapplication-TileColor" content="#e3e8fe"><meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml"><meta name="theme-color" content="#e3e8fe"><link rel="preload" href="/assets/fonts/inter/Inter-Regular.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="/assets/fonts/inter/Inter-ExtraBold.woff2" as="font" crossorigin="anonymous"><link type="text/css" rel="stylesheet" href="/assets/stylesheets/vendor/bulma-1.0.4.min.css"><link type="text/css" rel="stylesheet" href="/assets/stylesheets/ultramarine.css"><body id="signal" class="index has-navbar-fixed-top"><nav class="navbar signal-navbar is-fixed-top" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a href="/#signal"> <img class="signal-logo" src="/assets/images/header/logo.png"/> </a> <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="signalNavbar"> <span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span> </a></div><div id="signalNavbar" class="navbar-menu"><div class="navbar-end"> <a class="navbar-item get-signal" href="/download/">Get Signal</a> <a class="navbar-item" href="https://support.signal.org">Help</a> <a class="navbar-item" href="/blog/">Blog</a> <a class="navbar-item" href="/docs/">Developers</a> <a class="navbar-item" href="/workworkwork/">Careers</a> <a class="navbar-item" href="/donate/">Donate</a></div></div></div></nav><section id="specification" class="post"><article><div class="container content"><div class="columns is-centered"><div class="column is-8"> <img class="author" src="/assets/images/body/spaceship.png" style="margin-top: 0" /><h1 class="title text-center"> The ML-KEM Braid Protocol</h1><h3 class="subtitle"><p>Revision 1, 2025-02-21, Last Updated: 2025-09-26 [<a href="mlkembraid.pdf">PDF</a>]<p>Rolfe Schmidt</h3></div></div><div class="columns is-centered"><div class="column is-8"><div id="TOC"><h2 class="toc">Table of Contents</h2><ul><li><a href="#introduction" id="toc-introduction">1. Introduction</a><ul><li><a href="#sparse-continuous-key-agreement" id="toc-sparse-continuous-key-agreement">1.1 Sparse Continuous Key Agreement</a><li><a href="#incremental-kems" id="toc-incremental-kems">1.2 Incremental KEMs</a><ul><li><a href="#ml-kem-as-an-incremental-kem" id="toc-ml-kem-as-an-incremental-kem">1.2.1 ML-KEM as an Incremental KEM</a></ul><li><a href="#chunking-with-erasure-codes" id="toc-chunking-with-erasure-codes">1.3 Chunking with Erasure Codes</a></ul><li><a href="#the-ml-kem-braid-protocol" id="toc-the-ml-kem-braid-protocol">2. The ML-KEM Braid Protocol</a><ul><li><a href="#overview" id="toc-overview">2.1 Overview</a><li><a href="#parameters" id="toc-parameters">2.2 Parameters</a><li><a href="#messages" id="toc-messages">2.3 Messages</a><li><a href="#internal-authentication" id="toc-internal-authentication">2.4 Internal Authentication</a><ul><li><a href="#ratcheted-authenticator-state-variables" id="toc-ratcheted-authenticator-state-variables">Ratcheted Authenticator state variables</a><li><a href="#ratcheted-authenticator-functions" id="toc-ratcheted-authenticator-functions">Ratcheted Authenticator functions</a></ul><li><a href="#state-machine-and-transitions" id="toc-state-machine-and-transitions">2.5 State Machine and Transitions</a><ul><li><a href="#keysunsampled" id="toc-keysunsampled"><strong>KeysUnsampled</strong></a><li><a href="#keyssampled" id="toc-keyssampled"><strong>KeysSampled</strong></a><li><a href="#headersent" id="toc-headersent"><strong>HeaderSent</strong></a><li><a href="#ct1received" id="toc-ct1received"><strong>Ct1Received</strong></a><li><a href="#eksentct1received" id="toc-eksentct1received"><strong>EkSentCt1Received</strong></a><li><a href="#noheaderreceived" id="toc-noheaderreceived"><strong>NoHeaderReceived</strong></a><li><a href="#headerreceived" id="toc-headerreceived"><strong>HeaderReceived</strong></a><li><a href="#ct1sampled" id="toc-ct1sampled"><strong>Ct1Sampled</strong></a><li><a href="#ekreceivedct1sampled" id="toc-ekreceivedct1sampled"><strong>EkReceivedCt1Sampled</strong></a><li><a href="#ct1acknowledged" id="toc-ct1acknowledged"><strong>Ct1Acknowledged</strong></a><li><a href="#ct2sampled" id="toc-ct2sampled"><strong>Ct2Sampled</strong></a></ul><li><a href="#initialization" id="toc-initialization">2.6 Initialization</a></ul><li><a href="#security-considerations" id="toc-security-considerations">3. Security Considerations</a><ul><li><a href="#the-vulnerable-message-set" id="toc-the-vulnerable-message-set">3.1 The Vulnerable Message Set</a><li><a href="#alternate-kems" id="toc-alternate-kems">3.2 Alternate KEMs</a><li><a href="#optional-internal-authentication" id="toc-optional-internal-authentication">3.3 Optional internal authentication</a><li><a href="#bandwidth-limits-message-sizes-and-speed-of-pcs" id="toc-bandwidth-limits-message-sizes-and-speed-of-pcs">3.4 Bandwidth limits, message sizes, and speed of PCS</a><li><a href="#encoder-domain-size" id="toc-encoder-domain-size">3.5 Encoder domain size</a><li><a href="#alternate-encoders" id="toc-alternate-encoders">3.6 Alternate encoders</a><li><a href="#formal-verification-and-security-proofs" id="toc-formal-verification-and-security-proofs">3.7 Formal verification and security proofs</a><li><a href="#representation-of-epochs" id="toc-representation-of-epochs">3.8 Representation of epochs</a></ul><li><a href="#ipr" id="toc-ipr">4. IPR</a><li><a href="#acknowledgements" id="toc-acknowledgements">5. Acknowledgements</a></ul></div><h1 id="introduction">1. Introduction</h1><p>The ML-KEM Braid is a <em>Sparse Continuous Key Agreement (SCKA)</em> protocol that uses NIST standardized ML-KEM <span class="citation" data-cites="kyberfips203"><a href="#ref-kyberfips203" role="doc-biblioref">[1]</a></span> to allow two parties to produce a sequence of post-quantum secure shared secrets. These shared secrets have Forward Secrecy (FS) and Post-Compromise Security (PCS) properties that can carry over to higher level protocols such as a Double Ratchet protocol for secure messaging <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[2]</a></span>.<h2 id="sparse-continuous-key-agreement">1.1 Sparse Continuous Key Agreement</h2><p>The ping-pong style key exchange at the heart of the classical Double Ratchet protocol is called a <em>Continuous Key Agreement (CKA)</em> protocol. It has the desirable feature that it emits new shared secrets at every round trip, and these secrets can be passed to a higher-level protocol - like the Double Ratchet - to provide Post-Compromise Security.<p>The messages that must be passed for quantum-secure key agreement are much larger, though, so in the presence of bandwidth constraints a protocol may send these messages in pieces and will not be able to emit new shared secrets in each round trip. To capture this we follow <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[3]</a></span> and use the notion of <em>Sparse</em> Continuous Key Agreement (SCKA).<p>An SCKA protocol outputs an ordered sequence of shared secrets, and the position of a shared secret in this sequence is an unsigned integer called the <em>epoch identifier</em>, or simply the <em>epoch</em>. The notion of <em>epoch</em> is implicit in the Diffie-Hellman ratchet of the classic Double Ratchet protocol <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[2]</a></span>, but in that context the public ratchet key is sufficient to serve as the epoch identifier. In contrast, we need stronger property, such as the ability to strictly order the epochs without gaps, in order to ensure that we use the output keys correctly.<p>In an SCKA protocol, each party maintains state and exposes two functions:<ul><li><strong><em>Send(state) → (msg, sending_epoch, output_key)</em></strong>: Updates the state and returns <em>msg</em>, a message to be processed by the other party, <em>sending_epoch</em>, the identifier of the latest epoch guaranteed to be known by the other party on receipt of <em>msg</em>, and <em>output_key</em>, a nullable pair containing an epoch identifier and a shared secret for that epoch.<li><strong><em>Receive(state, msg) → (receiving_epoch, output_key)</em></strong>: Updates the state and returns <em>receiving_epoch</em>, the epoch identifier that was output by the other party as <em>sending_epoch</em> when they called <em>send()</em> to generate <em>msg</em>, and <em>output_key</em>, a nullable pair containing an epoch identifier and a shared secret for that epoch.</ul><p>Precise correctness and security definitions are given in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[3]</a></span>. Informally, for correctness, the two parties in the protocol must agree on the sequence of keys emitted and the values of <em>sending_epoch</em> and <em>receiving_epoch</em> must indicate the most recent epochs that can be used correctly.<ul><li><strong>Session key consistency:</strong> If Alice and Bob output keys <em>(ep, k)</em> and <em>(ep’, k’)</em> respectively where <em>ep = ep’</em>, then <em>k = k’</em>.<li><strong>Per-participant epoch uniqueness:</strong> Each party outputs at most one key per epoch.<li><strong>Sender epoch knowledge:</strong> When <em>Send()</em> returns sending_epoch, the sender possesses, or has possessed, the key for that epoch and all earlier epochs.<li><strong>Receiver epoch knowledge:</strong> When <em>Receive()</em> returns receiving_epoch, the receiver possesses, or has possessed, the key for that epoch and all earlier epochs.<br /><li><strong>Epoch agreement:</strong> <em>sending_epoch</em> from <em>Send()</em> equals <em>receiving_epoch</em> from the corresponding <em>Receive()</em>. Specifically, if Alice (respectively, Bob) calls <em>Send()</em> which returns <em>msg</em> and sending_epoch, then when Bob (respectively, Alice) calls <em>Receive(msg)</em>, it must return <em>receiving_epoch = sending_epoch</em>.</ul><h2 id="incremental-kems">1.2 Incremental KEMs</h2><p>Some lattice-based Key Encapsulation Mechanisms (KEMs) based on the Learning With Errors assumption take the form of a “noisy key exchange” followed by a small reconciliation message that allows the parties to arrive at an exact shared secret. Because of this, the ciphertexts for these KEMs consist of two parts: <em>ct1</em> is a possibly compressed public key and <em>ct2</em> is a reconciliation message. The important observation is that <em>ct1</em> can be computed without complete knowledge of any encapsulation key.<p>To allow KEM users to take advantage of this fact, these KEMs can expose the following <em>incremental interface</em>:<ul><li><strong>KeyGen(randomness) → (dk, ek_header, ek_vector)</strong>: Takes an array of random bits and returns a decapsulation key, <em>dk</em>, an <em>ek_header</em> with all information needed for a recipient to calculate <em>ct1</em>, and the “vector” part of the encapsulation key, <em>ek_vector</em>. We note that for some KEMs it is possible that the header could be empty.<li><strong>Encaps1(ek_header, randomness) → (encaps_secret, ct1, shared_secret)</strong>: Takes an encapsulation key header and an array of random bits as input and samples the first part of a new ciphertext. It returns <em>encaps_secret</em>, an encapsulation secret that holds the information needed to complete the encapsulation, <em>ct1</em>, the first component of a ciphertext, and <em>shared_secret</em>, the shared secret encapsulated by the ciphertext.<li><strong>Encaps2(encaps_secret, ek_header, ek_vector) → ct2</strong>: Takes an encapsulation secret, encapsulation key header, and encapsulation key vector and completes the encapsulation process, returning a reconciliation message, <em>ct2</em>.<li><strong>Decaps(dk, ct1, ct2) → shared_secret</strong>: Takes a decapsulation key and a complete ciphertext and returns the encapsulated shared secret.</ul><h3 id="ml-kem-as-an-incremental-kem">1.2.1 ML-KEM as an Incremental KEM</h3><p>ML-KEM <span class="citation" data-cites="kyberfips203"><a href="#ref-kyberfips203" role="doc-biblioref">[1]</a></span> encapsulation keys consist of a 32-byte seed followed by a larger noisy vector. This seed is required to compute the “compressed public key” part of a ciphertext, <em>ct1</em>. Due to the Fujisaki-Okamoto transform <span class="citation" data-cites="fo13"><a href="#ref-fo13" role="doc-biblioref">[4]</a></span> variant used by ML-KEM, we also need to know the SHA3-256 hash of the full encapsulation key to compute <em>ct1</em>. Thus an encapsulation key header for ML-KEM has the following fields:<ul><li><strong>ek_seed</strong>: A 32-byte seed.<li><strong>hek</strong>: The SHA3-256 hash of <em>ek_seed || ek_vector</em>.</ul><p>As discussed in <a href="#alternate-kems">Section 3.2</a>, ML-KEM use of the encapsulation key hash gives it key binding properties that go beyond standard IND-CCA security and this should be considered when evaluating the use of any alternate KEM.<h2 id="chunking-with-erasure-codes">1.3 Chunking with Erasure Codes</h2><p>An SCKA protocol sends large messages in pieces and must do this in a way that is robust, even in an adversarial network environment. To accomplish this a protocol can use <em>erasure codes</em> or <em>fountain codes</em>. Informally this can be thought of as breaking a message into a stream of chunks, and in this document any mention of a “chunk” of a message refers to a codeword of an erasure code.<h1 id="the-ml-kem-braid-protocol">2. The ML-KEM Braid Protocol</h1><h2 id="overview">2.1 Overview</h2><p>The ML-KEM Braid protocol takes advantage of the incremental interface ML-KEM described above to parallelize message sending and speed recovery from compromise. Specifically, the incremental interface allows <em>ct1</em> to be sampled after receiving just a <em>header</em>, after which <em>ct1</em> and <em>ek_vector</em> - the largest components of the ciphertext and encapsulation key - can be sent in parallel.<p>The following is a high level description of one epoch of the ML-KEM Braid protocol.<ul><li>A samples a new ML-KEM keypair: <em>(dk, ek_seed, ek_vector) = ML-KEM-KeyGen()</em>.<li>A encodes a header message, <em>ek_seed || SHA3-256(ek_seed || ek_vector)</em>, and begins sending it to B in chunks.<li>When B receives enough chunks to reconstruct the message, they decode and compute <em>(encaps_secret, ct1, shared_secret) = ML-KEM-Encaps1(ek_seed, SHA3-256(ek_seed || ek_vector))</em>. B stores <em>encaps_secret</em> and <em>shared_secret</em> for later use.<li>B encodes <em>ct1</em> and begins sending it to A in chunks.<li>When A receives the first chunk of <em>ct1</em>, they stop sending chunks of the header and start sending chunks of <em>ek_vector</em>.<li>Now A and B send their messages in parallel.<li>When A receives all of <em>ct1</em> they begin acknowledging the receipt in future messages sent to B.<li>Once B receives all of <em>ek_vector</em> and receives an acknowledgment that <em>ct1</em> was received, they compute <em>ct2 = ML-KEM-Encaps2(encaps_secret, ek_seed, ek_vector)</em>.<li>B encodes <em>ct2</em> and begins sending it to A in chunks.<li>When A receives the first chunk of <em>ct2</em>, they stop sending chunks of <em>ek_vector</em>.<li>When A receives all of <em>ct2</em>, they decapsulate the shared secret: <em>shared_secret = ML-KEM-Decaps(dk, ct1, ct2)</em>.<li>Now A and B switch roles. A begins waiting for a header message from B, and indicates it has moved to the next epoch when sending messages to B.<li>Once B receives a message showing that A has advanced to the next epoch, they sample a new keypair and begin again.</ul><p>While this captures the main flow of the protocol, it does not tell us how A and B know <em>when</em> they can use the keys returned by the protocol. Clearly, when B returns <em>shared_secret</em> above, they cannot use it to encrypt messages to A because A does not know <em>shared_secret</em> yet. This will be addressed by the values <em>sending_epoch</em> and <em>receiving_epoch</em> returned from the functions defined below - a value that tells the caller what latest epoch key known by both parties at the time a message was created.<p>The protocol below also performs optional authentication, with details presented in <a href="#internal-authentication">Section 2.4</a> and discussed further in <a href="#optional-internal-authentication">Section 3.3</a>.<h2 id="parameters">2.2 Parameters</h2><ul><li><strong><em>KEM</em></strong>: An IND-CPA secure Key Encapsulation Mechanism that offers an incremental interface. For this document it will be one of <em>ML-KEM-512</em>, <em>ML-KEM-768</em>, or <em>ML-KEM-1024</em>. The <strong><em>KEM</em></strong> exposes the incremental interface described in <a href="#incremental-kems">Section 1.2</a><li><strong>Constants</strong>: Several constants are also associated with the KEM and are needed in the protocol description:</ul><table><colgroup><col style="width: 26%" /><col style="width: 26%" /><col style="width: 21%" /><col style="width: 25%" /><thead><tr class="header"><th style="text-align: left;">Constant<th style="text-align: left;">ML-KEM 512<th style="text-align: left;">ML-KEM 768<th style="text-align: left;">ML-KEM 1024<tbody><tr class="odd"><td style="text-align: left;"><strong>HEADER_SIZE</strong><td style="text-align: left;">64<td style="text-align: left;">64<td style="text-align: left;">64<tr class="even"><td style="text-align: left;"><strong>EK_SIZE</strong><td style="text-align: left;">768<td style="text-align: left;">1152<td style="text-align: left;">1536<tr class="odd"><td style="text-align: left;"><strong>CT1_SIZE</strong><td style="text-align: left;">640<td style="text-align: left;">960<td style="text-align: left;">1408<tr class="even"><td style="text-align: left;"><strong>CT2_SIZE</strong><td style="text-align: left;">128<td style="text-align: left;">128<td style="text-align: left;">160</table><ul><li><p><strong><em>Encode/Decode</em></strong>: An erasure code or fountain code that can encode a long message into a stream of codewords, or chunks, so that when the receiver gets a sufficient number of these chunks, regardless of order or dropped codewords, they will be able to reconstruct the original message. Reed-Solomon based erasure codes over <em>GF(2<sup>16</sup>)<sup>w/2</sup></em> for a chunk size of <span class="math inline"><em>w</em></span> bytes are recommended.<ul><li><strong>Encode(byte_array) → encoder</strong>: Returns a stateful encoding object that produces a stream of codewords, or <em>chunks</em>, that can be decoded to reconstruct <em>byte_array</em>. These codewords are accessed by calling the method <em>encoder.next_chunk()</em>.<li><strong>Decoder.new(message_size) → decoder</strong>: Returns a stateful decoding object that will decode a message of length <em>message_size</em> from a set of codewords produced by a single encoder. It exposes the functions:<ul><li><strong>decoder.add_chunk(chunk)</strong>: Adds a codeword to the decoder’s state.<li><strong>decoder.has_message() → bool</strong>: Returns true when the decoder has received enough codewords to reconstruct the message.<li><strong>decoder.message() → maybe_byte_array</strong>: Returns the reconstructed message if possible, otherwise returns Null.</ul></ul><li><p><strong><em>EPOCH_TYPE</em></strong>: The unsigned integer type used to represent epochs. We recommend using unsigned 64-bit integers.<li><p><strong><em>ToBytes(epoch)</em></strong>: Represent an epoch as a byte string. When <em>EPOCH_TYPE</em> is a 64-bit unsigned integer, use of big-endian encoding is recommended.<li><p><strong><em>MAC(mac_key, msg)</em></strong>: A message authentication code. <em>HMAC-SHA256</em> is recommended.<li><p><strong><em>MAC_SIZE</em></strong>: Size of <em>MAC</em>’s output, in bytes.<li><p><strong><em>PROTOCOL_INFO</em></strong>: The concatenation of a protocol identifier, a string representation of <em>KEM</em>, and a string representation of <em>MAC</em>, separated with the delimiter “<code>_</code>”, such as “<code>MyProtocol_MLKEM768_SHA-256</code>”. The string representations of the ML-KEM Braid parameters are defined by the implementer.<li><p><strong><em>KDF_AUTH(root_key, update_key, epoch)</em></strong>: 64 bytes of output from the HKDF algorithm <span class="citation" data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[5]</a></span> using <em>hash</em> with inputs:<ul><li><em>HKDF input key material</em> = <em>update_key</em><li><em>HKDF salt</em> = <em>root_key</em><li><em>HKDF info</em> = PROTOCOL_INFO || “:Authenticator Update” || ToBytes(epoch)<li><em>HKDF length</em> = 64</ul><li><p><strong><em>KDF_OK(shared_secret, epoch)</em></strong>: 32 bytes of output from the HKDF algorithm <span class="citation" data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[5]</a></span> using <em>hash</em> with inputs:<ul><li><em>HKDF input key material</em> = <em>shared_secret</em><li><em>HKDF salt</em> = A zero-filled byte sequence with length equal to the <em>hash</em> output length, in bytes.<li><em>HKDF info</em> = PROTOCOL_INFO || “:SCKA Key” || ToBytes(epoch)<li><em>HKDF length</em> = 32</ul></ul><h2 id="messages">2.3 Messages</h2><p>Messages consist of the following fields:<ul><li><strong>epoch</strong> (unsigned integer): Current epoch being negotiated<li><strong>type</strong> (enum): One of <em>{None, Hdr, Ek, EkCt1Ack, Ct1Ack, Ct1, Ct2}</em> with the following meanings:<ul><li><em>None</em>: There is no payload<li><em>Hdr</em>: The payload contains a <em>chunk</em> of the header.<li><em>Ek</em>: The payload contains a <em>chunk</em> of the encapsulation key.<li><em>EkCt1Ack</em>: The payload contains a <em>chunk</em> of the encapsulation key, and the sender has completely received <em>ct1</em>.<li><em>Ct1Ack</em>: No payload, but the sender has completely received <em>ct1</em>.<li><em>Ct1</em>: The payload contains a <em>chunk</em> of <em>ct1</em>.<li><em>Ct2</em>: The payload contains a <em>chunk</em> of <em>ct2</em>.</ul><li><strong>data</strong> (bytes, optional): Erasure code chunk when <em>type</em> is not one of <em>{ None, Ct1Ack }</em></ul><p>In what follows we will describe messages logically using object notation. Implementations may use a custom compact binary format or a general purpose serialization tool such as Protocol Buffers <span class="citation" data-cites="protobuf"><a href="#ref-protobuf" role="doc-biblioref">[6]</a></span> to encode these messages. In the presence of bandwidth limits, implementers should consider that a custom format may allow larger chunk sizes and correspondingly improve post-compromise security (See <a href="#bandwidth-limits-message-sizes-and-speed-of-pcs">Section 3.4</a>).<h2 id="internal-authentication">2.4 Internal Authentication</h2><p>While messaging protocols such as the Double Ratchet <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[2]</a></span> provide ratcheted message authentication through the use of AEAD or explicit MACs on messages, it may be desirable for an SCKA protocol to provide internal authenticity guarantees. We attain this using a <em>Ratcheted Authenticator</em>.<h3 id="ratcheted-authenticator-state-variables">Ratcheted Authenticator state variables</h3><p>The Ratcheted Authenticator holds the following state:<ul><li><strong><em>root_key</em></strong>: a 32 byte value.<li><strong><em>mac_key</em></strong>: a 32 byte key for use with <em>MAC</em>.</ul><h3 id="ratcheted-authenticator-functions">Ratcheted Authenticator functions</h3><p>The Ratcheted Authenticator offers a function to update the internal state with new entropy as well as functions to compute and verify MACs on ciphertexts and header messages:<pre><code>    def Authenticator.Init(auth_state, epoch, key):
        auth_state = {root_key: &#39;\0&#39;*32, mac_key: None }
        auth_state.Update(epoch, key)

    def Authenticator.Update(auth_state, epoch, key):
        auth_state.root_key, auth_state.mac_key 
          = KDF_AUTH(auth_state.root_key, key, epoch)

    def Authenticator.MacHdr(auth_state, epoch, hdr):
        return MAC(
            auth_state.mac_key, 
            PROTOCOL_INFO || &quot;:ekheader&quot; || epoch || hdr, 
            MAC_SIZE)

    def Authenticator.MacCt(auth_state, epoch, ct):
        return MAC(
            auth_state.mac_key, 
            PROTOCOL_INFO || &quot;:ciphertext&quot; || epoch || ct, 
            MAC_SIZE)

    def Authenticator.VfyHdr(auth_state, epoch, hdr, expected_mac):
        if expected_mac != auth_state.MacHdr(epoch, hdr):
            FAIL

    def Authenticator.VfyCt(auth_state, epoch, ct, expected_mac):
        if expected_mac != auth_state.MacCt(epoch, ct):
            FAIL</code></pre><p>In the event of a verification failure, protocol participants should not proceed with the ML-KEM Braid session and should negotiate a new ML-KEM Braid session.<h2 id="state-machine-and-transitions">2.5 State Machine and Transitions</h2><p>We describe the protocol as a state machine that transitions from state to state when sending or receiving messages. The states and transitions can be seen in the following figure, which can serve as a helpful reference in the detailed descriptions that follow.<figure> <img src="braid-state-machine.png" alt="State machine transitions for the ML-KEM Braid Protocol. Each transition is labeled with a number that can be found in the pseudocode below." /><figcaption aria-hidden="true">State machine transitions for the ML-KEM Braid Protocol. Each transition is labeled with a number that can be found in the pseudocode below.</figcaption></figure><p>All states of the agents contain at least the following two variables:<ul><li><em>epoch</em>: an unsigned integer identifying the epoch of the key being negotiated.<li><em>auth</em>: an Authenticator object.</ul><p>The following describes the state of an agent when they are transmitting an encapsulation key and awaiting the corresponding ciphertext. For each state we define the SCKA <em>Send()</em> and <em>Receive()</em> functions.<h3 id="keysunsampled"><strong>KeysUnsampled</strong></h3><p>Represents an agent that is ready to sample a new KEM keypair on the next <em>send</em> event. It carries no additional state.<p>When sending a message, the <strong>KeysUnsampled</strong> agent samples a new keypair, starts sending a header message, and transitions into the <strong>KeysSampled</strong> state. The <strong>KeysUnsampled</strong> agent ignores all messages it receives:<pre><code>def KeysUnsampled.Send(state):
  # Generate keypair and header
  (dk, ek_seed, ek_vector) = KEM.KeyGen()
  hek = SHA3-256(ek_seed || ek_vector)
  header = ek_seed || hek
  mac = state.auth.MacHdr(state.epoch, header)
  header_encoder = Encode(header || mac)
  
  # Generate message
  chunk = header_encoder.next_chunk()
  msg = {epoch: state.epoch, type: Hdr, data: chunk}
  
  # Update state
  # Transition (1)
  state = KeysSampled(
    state.epoch, 
    state.auth, 
    dk, 
    ek_seed, 
    ek_vector, 
    hek, 
    header_encoder)
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def KeysUnsampled.Receive(state, msg):
  # No action taken
  output_key = None
  receiving_epoch = state.epoch - 1
  return (receiving_epoch, output_key)</code></pre><h3 id="keyssampled"><strong>KeysSampled</strong></h3><p>Represents an agent that has sampled a KEM keypair and is sending the header. Additional state includes:<ul><li><em>dk</em>: a KEM decapsulation key<li><em>ek_vector</em>: vector part of a KEM encapsulation key<li><em>header_encoder</em></ul><p>The <strong>KeysSampled</strong> agent sends chunks of the header. When it receives a message of type <em>Ct1</em> it knows that the other party has received the complete header so it transitions into the <strong>HeaderSent</strong> state, in which it will begin sending chunks of <em>ek_vector</em>:<pre><code>def KeysSampled.Send(state):
  # Generate next header chunk
  chunk = state.header_encoder.next_chunk()
  msg = {epoch: state.epoch, type: Hdr, data: chunk}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def KeysSampled.Receive(state, msg):
  output_key = None
  receiving_epoch = state.epoch - 1
  
  if msg.epoch == state.epoch and msg.type == Ct1:
      # Initialize ct1 decoder and ek encoder
      ct1_decoder = Decoder.new(KEM.CT1_SIZE)
      ct1_decoder.add_chunk(msg.data)
      ek_encoder = Encode(state.ek_vector)
      
      # Update state
      # Transition (2)
      state = HeaderSent(
        state.epoch, 
        state.auth, 
        state.dk, 
        ct1_decoder, 
        ek_encoder)
  
  return (receiving_epoch, output_key)
  </code></pre><h3 id="headersent"><strong>HeaderSent</strong></h3><p>Represents an agent that has completed sending a header, is currently sending an <em>ek_vector</em>, and is receiving chunks of <em>ct1</em>. Additional state includes:<ul><li><em>dk</em>: a KEM decapsulation key<li><em>ct1_decoder</em><li><em>ek_encoder</em></ul><p>In the <strong>HeaderSent</strong> state, an agent sends chunks of its <em>ek_vector</em>. When receiving a message of type <em>Ct1</em> for the current epoch, if it has enough chunks to decode the incoming <em>ct1</em>, it transitions to the <em>Ct1Received</em> state:<pre><code>def HeaderSent.Send(state):
  # Generate next ek_vector chunk
  chunk = state.ek_encoder.next_chunk()
  msg = {epoch: state.epoch, type: Ek, data: chunk}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def HeaderSent.Receive(state, msg):
  output_key = None
  receiving_epoch = state.epoch - 1
  
  if msg.epoch == state.epoch and msg.type == Ct1:
      # Add chunk to decoder
      state.ct1_decoder.add_chunk(msg.data)
      
      # Check if ct1 is complete
      if state.ct1_decoder.has_message():
          ct1 = state.ct1_decoder.message()
          
          # Update state
          # Transition (3)
          state = Ct1Received(
            state.epoch, 
            state.auth, 
            state.dk, 
            ct1, 
            state.ek_encoder)
  
  return (receiving_epoch, output_key)</code></pre><h3 id="ct1received"><strong>Ct1Received</strong></h3><p>Represents an agent that has completely received <em>ct1</em> and is still sending chunks of <em>ek_vector</em>. Additional state includes:<ul><li><em>dk</em>: a KEM decapsulation key<li><em>ct1</em>: The compressed public key part of a KEM ciphertext<li><em>ek_encoder</em></ul><p>In the <strong>Ct1Received</strong> state an agent sends chunks of the <em>ek_vector</em> until it receives a chunk of <em>ct2</em>. At that point it knows <em>ek_vector</em> has been received so it transitions into the <strong>EkSentCt1Received</strong> state:<pre><code>def Ct1Received.Send(state):
  # Generate next ek_vector chunk with acknowledgment
  chunk = state.ek_encoder.next_chunk()
  msg = {epoch: state.epoch, type: EkCt1Ack, data: chunk}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def Ct1Received.Receive(state, msg):
  output_key = None
  receiving_epoch = state.epoch - 1
  
  if msg.epoch == state.epoch and msg.type == Ct2:
      # Initialize ct2 decoder
      ct2_decoder = Decoder.new(KEM.CT2_SIZE + MAC_SIZE)
      ct2_decoder.add_chunk(msg.data)
      
      # Update state
      # Transition (4)
      state = EkSentCt1Received(
        state.epoch, 
        state.auth, 
        state.dk, 
        state.ct1, 
        ct2_decoder)
  
  return (receiving_epoch, output_key)</code></pre><h3 id="eksentct1received"><strong>EkSentCt1Received</strong></h3><p>Represents an agent that has received <em>ct1</em>, sent <em>ek</em>, and is receiving chunks of <em>ct2</em>. Additional state includes:<ul><li><em>dk</em>: a KEM decapsulation key<li><em>ct1</em>: The compressed public key part of a KEM ciphertext<li><em>ct2_decoder</em></ul><p>In the <strong>EkSentCt1Received</strong> state an agent doesn’t send any data to the other party and it receives chunks of <em>ct2</em>. Once <em>ct2</em> is received, it verifies the MAC, decapsulates the secret, emits the key, and transitions to the <strong>NoHeaderReceived</strong> state to wait for the other party to begin sending an encapsulation key for the next epoch:<pre><code>def EkSentCt1Received.Send(state):
  # No data to send
  msg = {epoch: state.epoch, type: None}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def EkSentCt1Received.Receive(state, msg):
  output_key = None
  receiving_epoch = state.epoch - 1
  
  if msg.epoch == state.epoch and msg.type == Ct2:
      # Add chunk to decoder
      state.ct2_decoder.add_chunk(msg.data)
      
      # Check if ct2 is complete
      if state.ct2_decoder.has_message():
          ct2_with_mac = state.ct2_decoder.message()
          ct2 = ct2_with_mac[:KEM.CT2_SIZE]
          mac = ct2_with_mac[KEM.CT2_SIZE:]
          
          # Decapsulate shared secret
          ss = KEM.Decaps(state.dk, state.ct1, ct2)
          ss = KDF_OK(ss, state.epoch)
          
          # Update authenticator and verify MAC
          state.auth.Update(state.epoch, ss)
          state.auth.VfyCt(state.epoch, state.ct1 || ct2, mac)
          
          # Prepare for next epoch
          header_decoder = Decoder.new(KEM.HEADER_SIZE + MAC_SIZE)
          
          # Update state and return key
          # Transition (5)
          state = NoHeaderReceived(
            state.epoch + 1, 
            state.auth, 
            header_decoder)
          output_key = (state.epoch - 1, ss)
  
  return (receiving_epoch, output_key)</code></pre><p>The following describes the state of an agent when they are transmitting a ciphertext in response to an encapsulation key.<h3 id="noheaderreceived"><strong>NoHeaderReceived</strong></h3><p>Represents an agent that is receiving a header. Additional state includes:<ul><li><em>header_decoder</em></ul><p>In the <strong>NoHeaderReceived</strong> state an agent receives chunks of the header. Once the header has been completely received, it transitions to the <strong>HeaderReceived</strong> state, but does not sample the ciphertext yet:<pre><code>def NoHeaderReceived.Send(state):
  # No data to send
  msg = {epoch: state.epoch, type: None}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def NoHeaderReceived.Receive(state, msg):
  output_key = None
  receiving_epoch = state.epoch - 1
  
  if msg.epoch == state.epoch and msg.type == Hdr:
      # Add chunk to decoder
      state.header_decoder.add_chunk(msg.data)
      
      # Check if header is complete
      if state.header_decoder.has_message():
          header_with_mac = state.header_decoder.message()
          header = header_with_mac[:64]
          mac = header_with_mac[64:]
          ek_seed = header[:32]
          hek = header[32:]
          
          # Verify header MAC
          state.auth.VfyHdr(state.epoch, header, mac)
          
          # Prepare ek_vector decoder
          ek_decoder = Decoder.new(KEM.EK_SIZE)
          
          # Update state
          # Transition (6)
          state = HeaderReceived(
            state.epoch, 
            state.auth, 
            ek_seed, 
            hek, 
            ek_decoder)
  
  return (receiving_epoch, output_key)</code></pre><h3 id="headerreceived"><strong>HeaderReceived</strong></h3><p>Represents an agent that has received a header and is prepared to sample a new <em>ct1</em> on the next send. Additional state includes:<ul><li><em>ek_seed</em>: seed of a KEM encapsulation key<li><em>hek</em>: SHA3 hash of <em>ek_seed || ek_vector</em><li><em>ek_decoder</em></ul><p>In the <strong>HeaderReceived</strong> state an agent is ready to sample a ciphertext when asked to send. When it does this, it computes the encapsulated shared secret for this epoch and returns it to the caller. While it has an <em>ek_decoder</em> prepared, it will not receive any <em>ek_vector</em> chunks until after it has sent a <em>ct1</em> message - and then it will have transitioned out of this state. So the <em>Receive</em> function is a no-op:<pre><code>def HeaderReceived.Send(state):
  # Generate shared secret and ct1
  (encaps_secret, ct1, ss) = KEM.Encaps1(state.ek_seed, state.hek)
  ss = KDF_OK(ss, state.epoch)
  
  # Update authenticator
  state.auth.Update(state.epoch, ss)
  
  # Encode ct1 for transmission
  ct1_encoder = Encode(ct1)
  chunk = ct1_encoder.next_chunk()
  msg = {epoch: state.epoch, type: Ct1, data: chunk}
  
  # Update state
  # Transition (7)
  state = Ct1Sampled(
    state.epoch, 
    state.auth, 
    state.ek_seed, 
    state.hek, 
    encaps_secret, 
    ct1, 
    ct1_encoder, 
    state.ek_decoder)
  
  # Return values
  output_key = (state.epoch, ss)
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def HeaderReceived.Receive(state, msg):
  # No action taken
  output_key = None
  receiving_epoch = state.epoch - 1
  return (receiving_epoch, output_key)</code></pre><h3 id="ct1sampled"><strong>Ct1Sampled</strong></h3><p>Represents an agent that has received a header, has sampled <em>ct1</em>, and is sending it in chunks. Additional state includes:<ul><li><em>ek_seed</em>: seed of a KEM encapsulation key<li><em>hek</em>: SHA3 hash of <em>ek_seed || ek_vector</em><li><em>encaps_secret</em>: the secret material used to encapsulate a KEM ciphertext<li><em>ct1</em>: The compressed public key part of a KEM ciphertext<li><em>ct1_encoder</em><li><em>ek_decoder</em></ul><p>The <strong>Ct1Sampled</strong> state has the most complex transition possibilities. In this state an agent is receiving chunks of <em>ek_vector</em> and sending chunks of <em>ct1</em>. If it receives all of <em>ek_vector</em> before receiving an acknowledgment that <em>ct1</em> was received, it will transition to <strong>EkReceivedCt1Sampled</strong>. On the other hand, if it receives an acknowledgment that <em>ct1</em> was received before <em>ek_vector</em> has been completely received, it will transition to <strong>Ct1Acknowledged</strong>. If this agent both receives an acknowledgment for <em>Ct1</em> and receives the last chunk of <em>ek_vector</em> in a single receive call, it will compute <em>ct1</em> and transition to <strong>Ct2Sampled</strong>:<pre><code>def Ct1Sampled.Send(state):
  # Generate next ct1 chunk
  chunk = state.ct1_encoder.next_chunk()
  msg = {epoch: state.epoch, type: Ct1, data: chunk}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def Ct1Sampled.Receive(state, msg):
  output_key = None
  receiving_epoch = state.epoch - 1
  
  if msg.epoch == state.epoch and msg.type == Ek:
      # Add ek_vector chunk
      state.ek_decoder.add_chunk(msg.data)
      
      # Check if ek_vector is complete
      if state.ek_decoder.has_message():
          ek_vector = state.ek_decoder.message()
          
          # Verify ek_vector integrity
          if SHA3-256(state.ek_seed || ek_vector) != state.hek:
              raise Error(&quot;EK integrity check failed&quot;)
          
          # Update state
          # Transition (10)
          state = EkReceivedCt1Sampled(
            state.epoch, 
            state.auth, 
            state.encaps_secret,
            state.ct1, 
            state.ek_seed, 
            ek_vector, 
            state.ct1_encoder)
  
  elif msg.epoch == state.epoch and msg.type == EkCt1Ack:
      # Add ek_vector chunk (with acknowledgment)
      state.ek_decoder.add_chunk(msg.data)
      
      # Check if ek_vector is complete
      if state.ek_decoder.has_message():
          ek_vector = state.ek_decoder.message()
          
          # Verify ek_vector integrity
          if SHA3-256(state.ek_seed || ek_vector) != state.hek:
              raise Error(&quot;EK integrity check failed&quot;)
          
          # Complete encapsulation
          ct2 = KEM.Encaps2(
            state.encaps_secret, state.ek_seed, ek_vector)
          mac = state.auth.MacCt(state.epoch, state.ct1 || ct2)
          ct2_encoder = Encode(ct2 || mac)
          
          # Update state
          # Transition (9)
          state = Ct2Sampled(state.epoch, state.auth, ct2_encoder)
      else:
          # Update state
          # Transition (8)
          state = Ct1Acknowledged(
            state.epoch, 
            state.auth, 
            state.encaps_secret,
            state.ek_seed, 
            state.hek, 
            state.ct1, 
            state.ek_decoder)
  
  return (receiving_epoch, output_key)</code></pre><h3 id="ekreceivedct1sampled"><strong>EkReceivedCt1Sampled</strong></h3><p>Represents an agent that has received an encapsulation key and is still sending <em>ct1</em> in chunks. Additional state includes:<ul><li><em>encaps_secret</em>: the secret material used to encapsulate a KEM ciphertext<li><em>ct1</em>: The compressed public key part of a KEM ciphertext<li><em>ek_seed</em><li><em>ek_vector</em><li><em>ct1_encoder</em></ul><p>In the <strong>EkReceivedCt1Sampled</strong> state an agent sends chunks of <em>ct1</em> and awaits an acknowledgment that it has been received. When that acknowledgment comes, it computes <em>ct2</em> and transitions to the <strong>Ct2Sampled</strong> state:<pre><code>def EkReceivedCt1Sampled.Send(state):
  # Generate next ct1 chunk
  chunk = state.ct1_encoder.next_chunk()
  msg = {epoch: state.epoch, type: Ct1, data: chunk}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def EkReceivedCt1Sampled.Receive(state, msg):
  output_key = None
  receiving_epoch = state.epoch - 1
  
  if msg.epoch == state.epoch and msg.type == EkCt1Ack:
      # Complete encapsulation
      ct2 = KEM.Encaps2(
        state.encaps_secret, state.ek_seed, state.ek_vector)
      mac = state.auth.MacCt(state.epoch, state.ct1 || ct2)
      ct2_encoder = Encode(ct2 || mac)
      
      # Update state
      # Transition (12)
      state = Ct2Sampled(state.epoch, state.auth, ct2_encoder)
  
  return (receiving_epoch, output_key)</code></pre><h3 id="ct1acknowledged"><strong>Ct1Acknowledged</strong></h3><p>Represents an agent that has completed sending <em>ct1</em> but is still receiving chunks of <em>ek_vector</em>. Additional state includes:<ul><li><em>ek_seed</em>: seed of a KEM encapsulation key<li><em>hek</em>: SHA3 hash of <em>ek_seed || ek_vector</em><li><em>encaps_secret</em>: the secret material used to encapsulate a KEM ciphertext<li><em>ct1</em>: The compressed public key part of a KEM ciphertext<li><em>ek_decoder</em></ul><p>In the <strong>Ct1Acknowledged</strong> state an agent receives chunks of an incoming <em>ek_vector</em>. Once this has been completely received, it can compute <em>ct2</em> and transition to the <strong>Ct2Sampled</strong> state:<pre><code>def Ct1Acknowledged.Send(state):
  # No data to send
  msg = {epoch: state.epoch, type: None}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def Ct1Acknowledged.Receive(state, msg):
  output_key = None
  receiving_epoch = state.epoch - 1
  
  if msg.epoch == state.epoch and msg.type == EkCt1Ack:
      # Add ek_vector chunk
      state.ek_decoder.add_chunk(msg.data)
      
      # Check if ek_vector is complete
      if state.ek_decoder.has_message():
          ek_vector = state.ek_decoder.message()
          
          # Verify ek_vector integrity
          if SHA3-256(state.ek_seed || ek_vector) != state.hek:
              raise Error(&quot;EK integrity check failed&quot;)
          
          # Complete encapsulation
          ct2 = KEM.Encaps2(
            state.encaps_secret, state.ek_seed, ek_vector)
          mac = state.auth.MacCt(state.epoch, state.ct1 || ct2)
          ct2_encoder = Encode(ct2 || mac)
          
          # Update state
          # Transition (11)
          state = Ct2Sampled(state.epoch, state.auth, ct2_encoder)
  
  return (receiving_epoch, output_key)</code></pre><h3 id="ct2sampled"><strong>Ct2Sampled</strong></h3><p>Represents an agent that has completed sending <em>ct1</em>, received <em>ek_vector</em>, and is sending <em>ct2</em>. Additional state includes:<ul><li><em>ct2_encoder</em></ul><p>In the <strong>Ct2Sampled</strong> state an agent sends chunks of <em>ct2</em> and waits for a message from the next epoch. Once a message from the next epoch is received, it transitions to the <strong>KeysUnsampled</strong> state and prepares to start sending a new encapsulation key:<pre><code>def Ct2Sampled.Send(state):
  # Generate next ct2 chunk
  chunk = state.ct2_encoder.next_chunk()
  msg = {epoch: state.epoch, type: Ct2, data: chunk}
  
  # Return values
  output_key = None
  sending_epoch = state.epoch - 1
  return (msg, sending_epoch, output_key)

def Ct2Sampled.Receive(state, msg):
  output_key = None
  
  if msg.epoch == state.epoch + 1:
      # Next epoch has begun
      # Transition (13)
      state = KeysUnsampled(state.epoch + 1, state.auth)

  receiving_epoch = state.epoch - 1
  return (receiving_epoch, output_key)</code></pre><h2 id="initialization">2.6 Initialization</h2><p>We initialize Alice and Bob’s protocol state using a preshared secret that may come from a handshake protocol such as PQXDH <span class="citation" data-cites="pqxdh"><a href="#ref-pqxdh" role="doc-biblioref">[7]</a></span>. Alice is initialized to begin sending an encapsulation key header, while Bob is initialized to expect to receive that header:<pre><code>    def InitAlice(shared_secret):
        epoch = 1
        auth = Authenticator.Init(epoch, shared_secret)
        return KeysUnsampled(epoch, auth)
    
    def InitBob(shared_secret):
        epoch = 1
        auth = Authenticator.Init(epoch, shared_secret)
        header_decoder = Decoder.new(KEM.HEADER_SIZE + MAC_SIZE)
        return NoHeaderReceived(epoch, auth, header_decoder)</code></pre><p>With this initialization, Alice and Bob will always be able to make forward progress as long as fresh messages are delivered. The graph of possible state transitions can be seen in the figure below.<figure> <img src="alice-bob-transitions.png" alt="The graph of all possible state transitions for Alice and Bob when Alice begins in the KeysUnsampled state and Bob begins in the NoHeaderReceived state. In each tuple, Alice’s state is on the left and Bob’s state is on the right. At the end of this process, Alice and Bob will have switched states and will have advanced one epoch." /><figcaption aria-hidden="true">The graph of all possible state transitions for Alice and Bob when Alice begins in the KeysUnsampled state and Bob begins in the NoHeaderReceived state. In each tuple, Alice’s state is on the left and Bob’s state is on the right. At the end of this process, Alice and Bob will have switched states and will have advanced one epoch.</figcaption></figure><h1 id="security-considerations">3. Security Considerations</h1><h2 id="the-vulnerable-message-set">3.1 The Vulnerable Message Set</h2><p>This protocol is designed to provide robust continuous key agreement in the presence of bandwidth limits. Since many messages must be passed in order to reach key agreement, the important measure of security provided by this protocol is “in the event of a compromise, how many messages are passed before healing?”. We call this the <em>vulnerable message set</em>.<p>The size of the vulnerable message set is not an intrinsic property of the protocol. For the ML-KEM Braid, given a chunk size and choice of KEM one can compute the <em>minimum</em> possible size of the vulnerable message set, but the <em>maximum</em> size of this set is unbounded: if Bob never replies to Alice but Alice continues sending messages, their session will never heal and all of Alice’s messages will be vulnerable.<p>In fact, as shown in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[3]</a></span>, the size of the vulnerable message set for a SCKA protocol depends on the message sending behavior of the protocol participants. Two parties that are online and in rapid conversation, such as two parties chatting using their primary devices in a Signal chat, will typically have a smaller vulnerable message set than will be found in a conversation between two parties on desktop devices that are often offline.<p>The ML-KEM Braid protocol was selected to provide small vulnerable message sets in a wide range of realistic secure messaging scenarios, but for applications with highly specific message sending behaviors protocol designers should consider whether a different SCKA protocol may provide better security.<h2 id="alternate-kems">3.2 Alternate KEMs</h2><p>This protocol uses ML-KEM as specified but we note that the IND-CCA security provided by ML-KEM’s Fujisaki-Okamoto transform is not required to prove the security of this or related SCKA protocols. In <span class="citation" data-cites="tripleratchet"><a href="#ref-tripleratchet" role="doc-biblioref">[8]</a></span> an IND-CPA “Ratcheting KEM” was designed with this fact in mind, and it allows a large part of a ciphertext to be reused as a public key for a future round, reducing bandwidth costs. Even without the ratcheting KEM optimization, this protocol could be made more efficient by having the parties use their shared session state to determine the encapsulation key seed, and then using the internal IND-CPA Public Key Encryption (PKE) functionality of ML-KEM. This would not only reduce message sizes by a small amount, it would allow us to skip sending the “header” and reduce the number of round trips required to emit a key. This could have a particularly large benefit in situations where communication is imbalanced, for example, when one party’s device is offline for long periods of time.<p>Alternate KEMs, or more generally IND-CPA PKE schemes designed for efficient ratcheting, may not have the same binding properties as ML-KEM. As seen in <span class="citation" data-cites="pqxdh-verification Cremers2024KeepingUW"><a href="#ref-pqxdh-verification" role="doc-biblioref">[9]</a>, <a href="#ref-Cremers2024KeepingUW" role="doc-biblioref">[10]</a></span>, these binding properties can have an impact on the security of higher level protocols. Developers using a variant of this protocol with alternate KEM should consider the security implications of these binding properties in their higher level protocol.<h2 id="optional-internal-authentication">3.3 Optional internal authentication</h2><p>The authenticator objects and the MACs that are added to header and ciphertext messages provide standalone authenticity guarantees for ML-KEM Braid messages and outputs at a cost of transmitting 64 bytes per epoch.<p>If this protocol is integrated into a higher level protocol, such as the Double Ratchet <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[2]</a></span>, that provides authentication, then protocol messages can derive authenticity from that and the internal authentication of the ML-KEM Braid protocol could be removed.<h2 id="bandwidth-limits-message-sizes-and-speed-of-pcs">3.4 Bandwidth limits, message sizes, and speed of PCS</h2><p>While the size of the vulnerable message set depends on the actual message sending behavior of the protocol participants, it is easy to see that if we send larger chunks, then key agreement - and eventual healing - will happen faster.<p>With a chunk size of 32, using ML-KEM 768 we require 3 messages to send a header, 30 messages to send <em>ct1</em>, 36 messages to send <em>ek_vector</em>, and 5 messages to send <em>ct2</em> with its MAC. If we doubled the chunk size to 64, these numbers will be cut in half (with upward rounding) and, under ideal conditions, healing would occur almost twice as fast. We note, though, that when parties go offline for periods of time, as is common with Signal’s linked devices, the benefits of larger chunks become less pronounced, as is seen in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[3]</a></span>. A doubling of the bandwidth limit will significantly improve the speed of PCS healing in many realistic settings but it will not lead to a doubling of healing speed. When considering the tradeoff between bandwidth usage and PCS speed, both client requirements and client message sending behavior should be considered.<p>In the presence of strict bandwidth limits, note that if a compact binary format is used to encode protocol messages and this format saves several bytes over a general purpose format, then those bytes can be used to send larger chunks and speed PCS.<h2 id="encoder-domain-size">3.5 Encoder domain size</h2><p>While in principle we think of encoders as producing an unbounded stream of codewords, in practice the encoder we recommend produces a finite number of distinct codewords before repeating. This means that an attacker with network control does not need to perform a complete denial of service attack on two parties to prevent the protocol from advancing: eventually codewords must be repeated and they can let any messages that repeat codewords through.<p>Internally, this is due to the fact that the encoding is implemented using polynomial interpolation over a finite field, and the number of distinct codewords is equal to the size of the underlying field.<p>We recommend using <em>GF(2<sup>16</sup>)</em> as the underlying field. When using ML-KEM 768 <span class="citation" data-cites="kyberfips203"><a href="#ref-kyberfips203" role="doc-biblioref">[1]</a></span> as the underlying KEM and 32-byte codewords, the largest message sent by the protocol is 36 codewords long. Thus to prevent ratcheting, an attacker must prevent 2<sup>16</sup> - 35 out of every 2<sup>16</sup> messages from being delivered. While this is not a complete denial of service, it requires blocking over 99.9% of messages and will likely cause protocol users to consider the underlying service to be unavailable.<p>Using <em>GF(2<sup>8</sup>)</em> would allow faster encoding and decoding, but now would allow an attacker to prevent the protocol from advancing by blocking 221 out of 256 messages, or 86% of messages. This will likely lead to a poor user experience, but may still render a higher level protocol usable. If encoding and decoding speed are critical for an application, we recommend considering the use of <em>fountain codes</em> as described in the next section.<h2 id="alternate-encoders">3.6 Alternate encoders</h2><p>We recommend using a systematic erasure code based encoding scheme to split large messages into fixed size chunks. Systematic encodings make the common case where no messages are dropped very efficient, since decoding is simply concatenation. Erasure codes give us a guarantee that, if a message’s plaintext fits into <em>N</em> codewords, then when the recipient receives any <em>N</em> codewords they will be able to decode the message.<p>If the computational costs of erasure code decoding are too high, a <em>fountain code</em>, such as RaptorQ <span class="citation" data-cites="rfc6330"><a href="#ref-rfc6330" role="doc-biblioref">[11]</a></span>, can be used. With a fountain code the recipient loses the <em>guarantee</em> that if a message’s plaintext fits into <em>N</em> codewords, then when the recipient receives any <em>N</em> codewords they will be able to decode the message. Nevertheless, the recipient will still be able to decode the message from <em>N</em> codewords in most situations. For RaptorQ, for example, decoders must succeed in decoding from <em>N</em> codewords at least 99 out of 100 times, and succeed decoding from <em>N+k</em> codewords with probability at least 1 - 10<sup>-k-1</sup>.<p>Since four messages must be decoded in each epoch, we can expect an implementation using RaptorQ to have to send more messages in an epoch than an erasure code based implementation about 4% of the time.<p>This may have a negative impact on the security of any higher level protocol. For example, in a Double Ratchet protocol <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[2]</a></span> using this would directly lead to an increase in the size of the Vulnerable Message Set - the set of messages exposed to an attacker in a device compromise - about 4% of the time. (See <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[3]</a></span> for more details on the Vulnerable Message Set).<h2 id="formal-verification-and-security-proofs">3.7 Formal verification and security proofs</h2><p>The ML-KEM Braid protocol has been modeled using ProVerif <span class="citation" data-cites="proverif"><a href="#ref-proverif" role="doc-biblioref">[12]</a></span> and has been proven, in the Dolev-Yao model, to provide the correctness, Forward Secrecy, and Post-Compromise Security required of an SCKA protocol as defined in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[3]</a></span>. Furthermore these models also prove mutual authentication for the ML-KEM Braid protocol.<p>The ML-KEM Braid protocol is closely related to the protocol Opp-UniKEM-CKA introduced and proven to be a secure SCKA in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[3]</a></span>.<p>The implementation and ProVerif models are available at <span class="citation" data-cites="sparsepostquantumratchet"><a href="#ref-sparsepostquantumratchet" role="doc-biblioref">[13]</a></span>.<h2 id="representation-of-epochs">3.8 Representation of epochs</h2><p>If an implementation uses a fixed width integer to represent the epoch, then eventually the epoch counter will repeat and the protocol loses the property that every epoch produces a unique key. For example, an application that uses 8-bit integers for epochs to conserve space in protocol messages will begin repeating epochs after 256 keys have been emitted - something that is likely to happen in many conversations. Using a 64-bit integer to represent the epoch will prevent this wraparound from ever happening in a human conversation, but for other applications of the ML-KEM Braid this wraparound should be considered.<h1 id="ipr">4. IPR</h1><p>This document is hereby placed in the public domain.<h1 id="acknowledgements">5. Acknowledgements</h1><p>The ML-KEM Braid protocol was designed by Graeme Connell and Rolfe Schmidt.<p>The notion of Sparse Continuous Key Agreement and the general opportunistic sending strategy underlying the ML-KEM Braid were introduced in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[3]</a></span>. The co-authors of this paper, Benedikt Auerbach, Yevgeniy Dodis, Daniel Jost, and Shuichi Katsumata contributed protocol design, analysis, and editorial feedback.<p>Karthik Bhargavan and Franziskus Kiefer were involved throughout the implementation process and contributed to the detailed design, modeling and analysis of the ML-KEM Braid using ProVerif, and provided editorial feedback on this documentation.<p>Thanks to Rune Fiedler, Charlie Jacomme and Nadim Kobeissi for valuable editorial feedback.<p>This work builds on the firm foundation the cryptography research community has created for us, and we deeply appreciate their continued efforts to improve our understanding of secure communication.<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list"><div id="ref-kyberfips203" class="csl-entry" role="listitem"><div class="csl-left-margin">[1]</div><div class="csl-right-inline"><span>“Module-lattice-based key-encapsulation mechanism standard.”</span> <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.ipd.pdf">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.ipd.pdf</a></div></div><div id="ref-doubleratchet" class="csl-entry" role="listitem"><div class="csl-left-margin">[2]</div><div class="csl-right-inline">T. Perrin and M. Marlinspike, <span>“<span>The Double Ratchet Algorithm</span>,”</span> 2016. <a href="https://signal.org/docs/specifications/doubleratchet/">https://signal.org/docs/specifications/doubleratchet/</a></div></div><div id="ref-comparesm" class="csl-entry" role="listitem"><div class="csl-left-margin">[3]</div><div class="csl-right-inline">B. Auerbach, Y. Dodis, D. Jost, S. Katsumata, and R. Schmidt, <span>“How to compare two-party secure messaging protocols: A quest for a more efficient and secure post-quantum protocol,”</span> 2025.</div></div><div id="ref-fo13" class="csl-entry" role="listitem"><div class="csl-left-margin">[4]</div><div class="csl-right-inline">E. Fujisaki and T. Okamoto, <span>“Secure integration of asymmetric and symmetric encryption schemes,”</span> J. Cryptol., vol. 26, no. 1, 2013. <a href="https://doi.org/10.1007/s00145-011-9114-1">https://doi.org/10.1007/s00145-011-9114-1</a></div></div><div id="ref-rfc5869" class="csl-entry" role="listitem"><div class="csl-left-margin">[5]</div><div class="csl-right-inline">H. Krawczyk and P. Eronen, <span>“<span class="nocase">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</span>.”</span> Internet Engineering Task Force; RFC 5869 (Informational); IETF, May-2010. <a href="http://www.ietf.org/rfc/rfc5869.txt">http://www.ietf.org/rfc/rfc5869.txt</a></div></div><div id="ref-protobuf" class="csl-entry" role="listitem"><div class="csl-left-margin">[6]</div><div class="csl-right-inline"><span>“Protocol buffers.”</span> <a href="https://protobuf.dev/">https://protobuf.dev/</a></div></div><div id="ref-pqxdh" class="csl-entry" role="listitem"><div class="csl-left-margin">[7]</div><div class="csl-right-inline">E. Kret and R. Schmidt, <span>“The PQXDH key agreement protocol,”</span> 2023. <a href="https://signal.org/docs/specifications/pqxdh/">https://signal.org/docs/specifications/pqxdh/</a></div></div><div id="ref-tripleratchet" class="csl-entry" role="listitem"><div class="csl-left-margin">[8]</div><div class="csl-right-inline">Y. Dodis, D. Jost, S. Katsumata, T. Prest, and R. Schmidt, <span>“Triple ratchet: A bandwidth efficient hybrid-secure signal protocol.”</span> Cryptology <span>ePrint</span> Archive, Paper 2025/078, 2025. <a href="https://eprint.iacr.org/2025/078">https://eprint.iacr.org/2025/078</a></div></div><div id="ref-pqxdh-verification" class="csl-entry" role="listitem"><div class="csl-left-margin">[9]</div><div class="csl-right-inline">K. Bhargavan, C. Jacomme, and F. Kiefer, <span>“PQXDH formal analysis git repository.”</span> <a href="https://github.com/Inria-Prosecco/pqxdh-analysis">https://github.com/Inria-Prosecco/pqxdh-analysis</a></div></div><div id="ref-Cremers2024KeepingUW" class="csl-entry" role="listitem"><div class="csl-left-margin">[10]</div><div class="csl-right-inline">C. J. F. Cremers, A. Dax, and N. Medinger, <span>“Keeping up with the KEMs: Stronger security notions for KEMs and automated analysis of KEM-based protocols,”</span> in Conference on computer and communications security, 2024. <a href="https://api.semanticscholar.org/CorpusID:268289969">https://api.semanticscholar.org/CorpusID:268289969</a></div></div><div id="ref-rfc6330" class="csl-entry" role="listitem"><div class="csl-left-margin">[11]</div><div class="csl-right-inline">M. Luby, A. Shokrollahi, M. Watson, T. Stockhammer, and L. Minder, <span>“<span class="nocase">RaptorQ Forward Error Correction Scheme for Object Delivery</span>.”</span> Internet Engineering Task Force; RFC 6330 (Proposed Standard); IETF, Aug-2011. <a href="http://www.ietf.org/rfc/rfc6330.txt">http://www.ietf.org/rfc/rfc6330.txt</a></div></div><div id="ref-proverif" class="csl-entry" role="listitem"><div class="csl-left-margin">[12]</div><div class="csl-right-inline"><span>“ProVerif.”</span> <a href="https://bblanche.gitlabpages.inria.fr/proverif/">https://bblanche.gitlabpages.inria.fr/proverif/</a></div></div><div id="ref-sparsepostquantumratchet" class="csl-entry" role="listitem"><div class="csl-left-margin">[13]</div><div class="csl-right-inline">S. Messenger, <span>“<span>Sparse Post-Quantum Ratchet</span>,”</span> 2025. <a href="https://github.com/signalapp/sparsepostquantumratchet">https://github.com/signalapp/sparsepostquantumratchet</a></div></div></div></div></div><div class="columns is-centered"><div class="column is-3"></div><div class="column is-6"><h3>Want to get involved with Signal? <a href="/workworkwork/">We're hiring!</a></h3></div><div class="column is-3"></div></div></div></article></section><footer class="footer"><div class="container"><div class="columns"><div class="column is-two-fifths is-hidden-mobile"> <span class="copyright">&copy; 2013&ndash;2026 Signal, a 501c3 nonprofit.</span><br /> "Signal", Signal logos, and other trademarks are trademarks or registered trademarks of Signal Technology Foundation in the United States and other countries (<a href="/brand/">more info here</a>). <br /> <br /> For media inquiries, contact <a href="/cdn-cgi/l/email-protection#b0c0c2d5c3c3f0c3d9d7ded1dc9edfc2d7"><span class="__cf_email__" data-cfemail="9fefedfaececdfecf6f8f1fef3b1f0edf8">[email&#160;protected]</span></a></div><div class="column"> <strong>Organization</strong><ul><li> <a href="/donate/">Donate</a><li> <a href="/workworkwork/">Careers</a><li> <a href="/blog/">Blog</a><li> <a href="/brand/">Brand Assets</a><li> <a href="/legal/">Terms &amp; Privacy Policy</a></ul></div><div class="column"> <strong>Download</strong><ul><li> <a href="/download/android/">Android</a><li> <a href="/download/ios/">iPhone & iPad</a><li> <a href="/download/windows/">Windows</a><li> <a href="/download/macos/">Mac</a><li> <a href="/download/linux/">Linux</a></ul></div><div class="column"> <strong>Social</strong><ul><li> <a href="https://bsky.app/profile/signal.org" target="_blank">Bluesky</a><li> <a href="https://github.com/signalapp" target="_blank">GitHub</a><li> <a href="https://www.instagram.com/signal_app/" target="_blank">Instagram</a><li> <a href="https://mastodon.world/@signalapp" target="_blank">Mastodon</a><li> <a href="https://x.com/signalapp" target="_blank">X</a></ul></div><div class="column"> <strong>Help</strong><ul><li> <a href="https://support.signal.org">Support Center</a><li> <a href="https://community.signalusers.org/">Community</a></ul></div><div class="column is-two-fifths is-hidden-tablet"> <span class="copyright">&copy; 2013&ndash;2026 Signal, a 501c3 nonprofit.</span><br /> "Signal", Signal logos, and other trademarks are trademarks or registered trademarks of Signal Technology Foundation in the United States and other countries (<a href="/brand/">more info here</a>). <br /> <br /> For media inquiries, contact <a href="/cdn-cgi/l/email-protection#79090b1c0a0a390a101e17181557160b1e"><span class="__cf_email__" data-cfemail="ef9f9d8a9c9caf9c8688818e83c1809d88">[email&#160;protected]</span></a></div></div></div></footer><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript" src="/assets/javascripts/vendor/jquery-3.7.1.min.js"></script> <script type="text/javascript" src="/assets/javascripts/vendor/lottie-player-2.0.3.min.js"></script> <script type="text/javascript"> document.addEventListener('DOMContentLoaded', () => { var userAgent = navigator.userAgent.toLowerCase(); var isIOS = ( userAgent.indexOf('iphone') !== -1 || userAgent.indexOf('ipad') !== -1 || userAgent.indexOf('ipod') !== -1 ); var isAndroid = userAgent.indexOf('android') !== -1; var $downloadSignal = $('.get-signal'); if (isIOS || isAndroid) { var url = isIOS ? 'https://apps.apple.com/us/app/signal-private-messenger/id874139669' : 'https://play.google.com/store/apps/details?id=org.thoughtcrime.securesms'; $downloadSignal.prop('href', url); $downloadSignal.html('<span>Get Signal</span> <i class="icon icon-external-link-alt"></i>'); } const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger')); if ($navbarBurgers.length > 0) { $navbarBurgers.forEach((el) => { el.addEventListener('click', () => { const target = el.dataset.target; const $target = document.getElementById(target); el.classList.toggle('is-active'); $target.classList.toggle('is-active'); }); }); } }); </script>
