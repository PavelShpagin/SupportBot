<!DOCTYPE html><html lang="en" data-theme="light"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content=""><meta name="author" content=""><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/blog/rss.xml" /><meta property="og:title" content="Signal Messenger: Speak Freely" /><meta property="og:site_name" content="Signal Messenger" /><meta property="og:type" content="website" /><meta property="og:description" content="Say &quot;hello&quot; to a different messaging experience. An unexpected focus on privacy, combined with all of the features you expect." /><meta property="og:url" content="https://signal.org/docs/specifications/pqxdh/" /><meta property="og:image" content="https://signal.org/assets/images/og/og-image.png" /><meta property="og:image:width" content="1200" /><meta property="og:image:height" content="630" /><meta name="twitter:site" content="@signalapp"><meta name="twitter:card" content="app"><meta name="twitter:app:name:iphone" content="Signal"><meta name="twitter:app:id:iphone" content="874139669"><meta name="twitter:app:name:googleplay" content="Signal"><meta name="twitter:app:id:googleplay" content="org.thoughtcrime.securesms"><title>Signal >> Specifications &gt;&gt; The PQXDH Key Agreement Protocol</title><link rel="me" href="https://mastodon.world/@signalapp"><link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/svg+xml" href="/assets/images/favicon/favicon.svg"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png"><link rel="manifest" href="/assets/images/favicon/site.webmanifest"><link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#3b45fd"><meta name="msapplication-TileColor" content="#e3e8fe"><meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml"><meta name="theme-color" content="#e3e8fe"><link rel="preload" href="/assets/fonts/inter/Inter-Regular.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="/assets/fonts/inter/Inter-ExtraBold.woff2" as="font" crossorigin="anonymous"><link type="text/css" rel="stylesheet" href="/assets/stylesheets/vendor/bulma-1.0.4.min.css"><link type="text/css" rel="stylesheet" href="/assets/stylesheets/ultramarine.css"><body id="signal" class="index has-navbar-fixed-top"><nav class="navbar signal-navbar is-fixed-top" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a href="/#signal"> <img class="signal-logo" src="/assets/images/header/logo.png"/> </a> <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="signalNavbar"> <span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span> </a></div><div id="signalNavbar" class="navbar-menu"><div class="navbar-end"> <a class="navbar-item get-signal" href="/download/">Get Signal</a> <a class="navbar-item" href="https://support.signal.org">Help</a> <a class="navbar-item" href="/blog/">Blog</a> <a class="navbar-item" href="/docs/">Developers</a> <a class="navbar-item" href="/workworkwork/">Careers</a> <a class="navbar-item" href="/donate/">Donate</a></div></div></div></nav><section id="specification" class="post"><article><div class="container content"><div class="columns is-centered"><div class="column is-8"> <img class="author" src="/assets/images/body/spaceship.png" style="margin-top: 0" /><h1 class="title text-center"> The PQXDH Key Agreement Protocol</h1><h3 class="subtitle"><p>Revision 3, 2023-05-24, Last Updated: 2024-01-23 [<a href="pqxdh.pdf">PDF</a>]<p>Ehren Kret, Rolfe Schmidt</h3></div></div><div class="columns is-centered"><div class="column is-8"><div id="TOC"><h2 class="toc">Table of Contents</h2><ul><li><a href="#introduction" id="toc-introduction">1. Introduction</a><li><a href="#preliminaries" id="toc-preliminaries">2. Preliminaries</a><ul><li><a href="#pqxdh-parameters" id="toc-pqxdh-parameters">2.1. PQXDH parameters</a><li><a href="#cryptographic-notation" id="toc-cryptographic-notation">2.2. Cryptographic notation</a><li><a href="#roles" id="toc-roles">2.3. Roles</a><li><a href="#elliptic-curve-keys" id="toc-elliptic-curve-keys">2.4. Elliptic Curve Keys</a><li><a href="#post-quantum-key-encapsulation-keys" id="toc-post-quantum-key-encapsulation-keys">2.5. Post-Quantum Key Encapsulation Keys</a></ul><li><a href="#the-pqxdh-protocol" id="toc-the-pqxdh-protocol">3. The PQXDH protocol</a><ul><li><a href="#overview" id="toc-overview">3.1. Overview</a><li><a href="#publishing-keys" id="toc-publishing-keys">3.2. Publishing keys</a><li><a href="#sending-the-initial-message" id="toc-sending-the-initial-message">3.3. Sending the initial message</a><li><a href="#receiving-the-initial-message" id="toc-receiving-the-initial-message">3.4. Receiving the initial message</a></ul><li><a href="#security-considerations" id="toc-security-considerations">4. Security considerations</a><ul><li><a href="#authentication" id="toc-authentication">4.1. Authentication</a><li><a href="#protocol-replay" id="toc-protocol-replay">4.2. Protocol replay</a><li><a href="#replay-and-key-reuse" id="toc-replay-and-key-reuse">4.3. Replay and key reuse</a><li><a href="#deniability" id="toc-deniability">4.4. Deniability</a><li><a href="#signatures" id="toc-signatures">4.5. Signatures</a><li><a href="#key-compromise" id="toc-key-compromise">4.6. Key compromise</a><li><a href="#passive-quantum-adversaries" id="toc-passive-quantum-adversaries">4.7. Passive quantum adversaries</a><li><a href="#active-quantum-adversaries" id="toc-active-quantum-adversaries">4.8. Active quantum adversaries</a><li><a href="#server-trust" id="toc-server-trust">4.9. Server trust</a><li><a href="#identity-binding" id="toc-identity-binding">4.10. Identity binding</a><li><a href="#risks-of-weak-randomness-sources" id="toc-risks-of-weak-randomness-sources">4.11. Risks of weak randomness sources</a><li><a href="#preventing-kem-re-encapsulation-attacks" id="toc-preventing-kem-re-encapsulation-attacks">4.12 Preventing KEM Re-encapsulation Attacks</a><li><a href="#key-identifiers" id="toc-key-identifiers">4.13 Key Identifiers</a></ul><li><a href="#ipr" id="toc-ipr">5. IPR</a><li><a href="#acknowledgements" id="toc-acknowledgements">6. Acknowledgements</a><li><a href="#references" id="toc-references">7. References</a></ul></div><h1 id="introduction">1. Introduction</h1><p>This document describes the “PQXDH” (or “Post-Quantum Extended Diffie-Hellman”) key agreement protocol. PQXDH establishes a shared secret key between two parties who mutually authenticate each other based on public keys. PQXDH provides post-quantum forward secrecy and a form of cryptographic deniability but still relies on the hardness of the discrete log problem for mutual authentication in this revision of the protocol.<p>PQXDH is designed for asynchronous settings where one user (“Bob”) is offline but has published some information to a server. Another user (“Alice”) wants to use that information to send encrypted data to Bob, and also establish a shared secret key for future communication.<h1 id="preliminaries">2. Preliminaries</h1><h2 id="pqxdh-parameters">2.1. PQXDH parameters</h2><p>An application using PQXDH must decide on several parameters:<table style="width:96%;"><colgroup><col style="width: 16%" /><col style="width: 79%" /><thead><tr class="header"><th style="text-align: left;">Name<th style="text-align: left;">Definition<tbody><tr class="odd"><td style="text-align: left;"><em>curve</em><td style="text-align: left;">A Montgomery curve for which XEdDSA <span class="citation" data-cites="xeddsa"><a href="#ref-xeddsa" role="doc-biblioref">[1]</a></span> is specified, at present this is one of curve25519 or curve448<tr class="even"><td style="text-align: left;"><em>hash</em><td style="text-align: left;">A 256 or 512-bit hash function (e.g. SHA-256 or SHA-512)<tr class="odd"><td style="text-align: left;"><em>info</em><td style="text-align: left;">An ASCII string identifying the application with a minimum length of 8 bytes<tr class="even"><td style="text-align: left;"><em>pqkem</em><td style="text-align: left;">A post-quantum key encapsulation mechanism that has IND-CCA post-quantum security (e.g. Crystals-Kyber-1024 <span class="citation" data-cites="kyberfips203"><a href="#ref-kyberfips203" role="doc-biblioref">[2]</a></span>)<tr class="odd"><td style="text-align: left;"><em>aead</em><td style="text-align: left;">A scheme for authenticated encryption with associated data that has IND-CPA and INT-CTXT post-quantum security<tr class="even"><td style="text-align: left;"><em>EncodeEC</em><td style="text-align: left;">A function that encodes a <em>curve</em> public key into a byte sequence<tr class="odd"><td style="text-align: left;"><em>DecodeEC</em><td style="text-align: left;">A function that decodes a byte sequence into a <em>curve</em> public key and is the inverse of <em>EncodeEC</em><tr class="even"><td style="text-align: left;"><em>EncodeKEM</em><td style="text-align: left;">A function that encodes a <em>pqkem</em> public key into a byte sequence<tr class="odd"><td style="text-align: left;"><em>DecodeKEM</em><td style="text-align: left;">A function that decodes a byte sequence into a <em>pqkem</em> public key and is the inverse of <em>EncodeKEM</em></table><p>For example, an application could choose <em>curve</em> as curve25519, <em>hash</em> as SHA-512, <em>info</em> as “MyProtocol”, and <em>pqkem</em> as CRYSTALS-KYBER-1024.<p>The ranges of all encoding functions must be pairwise disjoint.<p>The recommended implementation of <em>EncodeEC</em> consists of a single-byte constant representation of <em>curve</em> followed by little-endian encoding of the u-coordinate as specified in <span class="citation" data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[3]</a></span>. The single-byte representation of <em>curve</em> is defined by the implementer. Similarly the recommended implementation of <em>DecodeEC</em> reads the first byte to determine the parameter <em>curve</em>. If the first byte does not represent a recognized curve, the function fails. Otherwise it applies the little-endian decoding of the u-coordinate for <em>curve</em> as specified in <span class="citation" data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[3]</a></span>.<p>The recommended implementation of <em>EncodeKEM</em> consists of a single-byte constant representation of <em>pqkem</em> followed by the encoding of the <em>pqkem</em> public key specified by <em>pqkem</em>. The single-byte representation of <em>pqkem</em> is defined by the implementer. Similarly the recommended implementation of <em>DecodeKEM</em> reads the first byte to determine the parameter <em>pqkem</em>. If the first byte does not represent a recognized key encapsulation mechanism, the function fails. Otherwise it applies the decoding specified by the selected key encapsulation mechanism.<h2 id="cryptographic-notation">2.2. Cryptographic notation</h2><p>Throughout this document, all public keys have a corresponding private key, but to simplify descriptions we will identify key pairs by the public key and assume that the corresponding private key can be accessed by the key owner.<p>This document will use the following notation:<ul><li><p>The concatenation of byte sequences <strong><em>X</em></strong> and <strong><em>Y</em></strong> is <strong><em>X</em></strong> || <strong><em>Y</em></strong>.<li><p><strong><em>DH(PK1, PK2)</em></strong> represents a byte sequence which is the shared secret output from an Elliptic Curve Diffie-Hellman function involving the key pairs represented by public keys <em>PK1</em> and <em>PK2</em>. The Elliptic Curve Diffie-Hellman function will be either the X25519 or X448 function from <span class="citation" data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[3]</a></span>, depending on the <em>curve</em> parameter.<li><p><strong><em>Sig(PK, M, Z)</em></strong> represents the byte sequence that is a <em>curve</em> XEdDSA signature on the byte sequence <em>M</em> which was created by signing <em>M</em> with <em>PK</em>’s corresponding private key and using 64 bytes of randomness <em>Z</em>. This signature verifies with public key <em>PK</em>. The signing and verification functions for XEdDSA are specified in <span class="citation" data-cites="xeddsa"><a href="#ref-xeddsa" role="doc-biblioref">[1]</a></span>.<li><p><strong><em>KDF(KM)</em></strong> represents 32 bytes of output from the HKDF algorithm <span class="citation" data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[4]</a></span> using <em>hash</em> with inputs:<ul><li><em>HKDF input key material</em> = <em>F</em> || <em>KM</em>, where <em>KM</em> is an input byte sequence containing secret key material, and <em>F</em> is a byte sequence containing 32 0xFF bytes if <em>curve</em> is curve25519, and 57 0xFF bytes if <em>curve</em> is curve448. As in in XEdDSA <span class="citation" data-cites="xeddsa"><a href="#ref-xeddsa" role="doc-biblioref">[1]</a></span>, <em>F</em> ensures that the first bits of the HKDF input key material are never a valid encoding of a scalar or elliptic curve point.<li><em>HKDF salt</em> = A zero-filled byte sequence with length equal to the <em>hash</em> output length, in bytes.<li><em>HKDF info</em> = The concatenation of string representations of the 4 PQXDH parameters <em>info</em>, <em>curve</em>, <em>hash</em>, and <em>pqkem</em> into a single string separated with ‘<code>_</code>’ such as “<code>MyProtocol_CURVE25519_SHA-512_CRYSTALS-KYBER-1024</code>”. The string representations of the PQXDH parameters are defined by the implementer.</ul><li><p><strong><em>(CT, SS) = PQKEM-ENC(PK)</em></strong> represents a tuple of the byte sequence that is the KEM ciphertext, <em>CT</em>, output by the algorithm <em>pqkem</em> together with the shared secret byte sequence <em>SS</em> encapsulated by the ciphertext using the public key <em>PK</em>.<li><p><strong><em>PQKEM-DEC(PK, CT)</em></strong> represents the shared secret byte sequence <em>SS</em> decapsulated from a <em>pqkem</em> ciphertext using the private key counterpart of the public key <em>PK</em> used to encapsulate the ciphertext CT.</ul><h2 id="roles">2.3. Roles</h2><p>The PQXDH protocol involves three parties: <strong>Alice</strong>, <strong>Bob</strong>, and a <strong>server</strong>.<ul><li><p><strong>Alice</strong> wants to send <strong>Bob</strong> some initial data using encryption, and also establish a shared secret key which may be used for bidirectional communication.<li><p><strong>Bob</strong> wants to allow parties like <strong>Alice</strong> to establish a shared key with him and send encrypted data. However, <strong>Bob</strong> might be offline when <strong>Alice</strong> attempts to do this. To enable this, <strong>Bob</strong> has a relationship with some <strong>server</strong>.<li><p>The <strong>server</strong> can store messages from <strong>Alice</strong> to <strong>Bob</strong> which <strong>Bob</strong> can later retrieve. The <strong>server</strong> also lets <strong>Bob</strong> publish some data which the server will provide to parties like <strong>Alice</strong>. The amount of trust placed in the server is discussed in <a href="#server-trust">Section 4.9</a>.</ul><p>In some systems the <strong>server</strong> role might be divided between multiple entities, but for simplicity we assume a single server that provides the above functions for <strong>Alice</strong> and <strong>Bob</strong>.<h2 id="elliptic-curve-keys">2.4. Elliptic Curve Keys</h2><p>PQXDH uses the following elliptic curve public keys:<table style="width:94%;"><colgroup><col style="width: 47%" /><col style="width: 47%" /><thead><tr class="header"><th style="text-align: left;">Name<th style="text-align: left;">Definition<tbody><tr class="odd"><td style="text-align: left;"><em>IK<sub>A</sub></em><td style="text-align: left;">Alice’s identity key<tr class="even"><td style="text-align: left;"><em>IK<sub>B</sub></em><td style="text-align: left;">Bob’s identity key<tr class="odd"><td style="text-align: left;"><em>EK<sub>A</sub></em><td style="text-align: left;">Alice’s ephemeral key<tr class="even"><td style="text-align: left;"><em>SPK<sub>B</sub></em><td style="text-align: left;">Bob’s signed prekey<tr class="odd"><td style="text-align: left;">(<em>OPK<sub>B</sub><sup>1</sup></em>, <em>OPK<sub>B</sub><sup>2</sup></em>, …)<td style="text-align: left;">Bob’s set of one-time prekeys</table><p>The elliptic curve public keys used within a PQXDH protocol run must either all be in curve25519 form, or they must all be in curve448 form, depending on the <em>curve</em> parameter <span class="citation" data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[3]</a></span>.<p>Each party has a long-term identity elliptic curve public key (<em>IK<sub>A</sub></em> for Alice, <em>IK<sub>B</sub></em> for Bob).<p>Bob also has a signed prekey <em>SPK<sub>B</sub></em>, which he changes periodically and signs each time with <em>IK<sub>B</sub></em>, and a set of one-time prekeys (<em>OPK<sub>B</sub><sup>1</sup></em>, <em>OPK<sub>B</sub><sup>2</sup></em>, …), which are each used in a single PQXDH protocol run. For each signed prekey or one-time prekey, <em>K</em>, that Bob generates, he also computes an identifier, denoted <em>IdEC(K)</em>, that uniquely identifies this key on Bob’s device. (“Prekeys” are so named because they are essentially protocol messages which Bob publishes to the server, along with their corresponding identifiers, prior to Alice beginning the protocol run.) These keys will be uploaded to the <strong>server</strong> as described in <a href="#publishing-keys">Section 3.2</a>.<p>During each protocol run, Alice generates a new ephemeral key pair with public key <em>EK<sub>A</sub></em>.<h2 id="post-quantum-key-encapsulation-keys">2.5. Post-Quantum Key Encapsulation Keys</h2><p>PQXDH uses the following post-quantum key encapsulation public keys:<table><colgroup><col style="width: 44%" /><col style="width: 55%" /><thead><tr class="header"><th style="text-align: left;">Name<th style="text-align: left;">Definition<tbody><tr class="odd"><td style="text-align: left;"><em>PQSPK<sub>B</sub></em><td style="text-align: left;">Bob’s signed last-resort <em>pqkem</em> prekey<tr class="even"><td style="text-align: left;">(<em>PQOPK<sub>B</sub><sup>1</sup></em>, <em>PQOPK<sub>B</sub><sup>2</sup></em>, …)<td style="text-align: left;">Bob’s set of signed one-time <em>pqkem</em> prekeys</table><p>The <em>pqkem</em> public keys used within a PQXDH protocol run must all use the same <em>pqkem</em> parameter.<p>Bob has a signed last-resort post-quantum prekey <em>PQSPK<sub>B</sub></em>, which he changes periodically and signs each time with <em>IK<sub>B</sub></em>, and a set of signed one-time prekeys (<em>PQOPK<sub>B</sub><sup>1</sup></em>, <em>PQOPK<sub>B</sub><sup>2</sup></em>, …) which are also signed with <em>IK<sub>B</sub></em> and each used in a single PQXDH protocol run. For each last-resort or ephemeral KEM key, <em>K</em>, that Bob generates, he also computes an identifier, denoted <em>IdKEM(K)</em>, that uniquely identifies this key on Bob’s device. These keys and their corresponding identifiers will be uploaded to the <strong>server</strong> as described in <a href="#publishing-keys">Section 3.2</a>. The name “last-resort” refers to the fact that the last-resort prekey is only used when one-time <em>pqkem</em> prekeys are not available. This can happen when the number of prekey bundles downloaded for Bob exceeds the number of one-time <em>pqkem</em> prekeys Bob has uploaded (see <a href="#the-pqxdh-protocol">Section 3</a> for details about the role of the server). An implementation should provide Bob a way to identify whether a <em>pqkem</em> public key corresponds to a one-time <em>pqkem</em> key or a last-resort <em>pqkem</em> key.<h1 id="the-pqxdh-protocol">3. The PQXDH protocol</h1><h2 id="overview">3.1. Overview</h2><p>PQXDH has three phases:<ol type="1"><li><p>Bob publishes his elliptic curve identity key, elliptic curve prekeys, and <em>pqkem</em> prekeys to a server.<li><p>Alice fetches a “prekey bundle” from the server, and uses it to send an initial message to Bob.<li><p>Bob receives and processes Alice’s initial message.</ol><p>The following sections explain these phases.<h2 id="publishing-keys">3.2. Publishing keys</h2><p>Bob generates a sequence of 64-byte random values <em>Z<sub>SPK</sub>, Z<sub>PQSPK</sub>, Z<sub>1</sub>, Z<sub>2</sub>, …</em> and publishes a set of keys to the server containing:<ul><li>Bob’s <em>curve</em> identity key <em>IK<sub>B</sub></em><li>Bob’s signed <em>curve</em> prekey and its identifier <em>(SPK<sub>B</sub>, IdEC(SPK<sub>B</sub>))</em><li>Bob’s signature on the <em>curve</em> prekey <em>Sig(IK<sub>B</sub>, EncodeEC(SPK<sub>B</sub>), Z<sub>SPK</sub>)</em><li>Bob’s signed last-resort <em>pqkem</em> prekey and its identifier <em>(PQSPK<sub>B</sub>, IdKEM(PQSPK<sub>B</sub>))</em><li>Bob’s signature on the <em>pqkem</em> prekey <em>Sig(IK<sub>B</sub>, EncodeKEM(PQSPK<sub>B</sub>), Z<sub>PQSPK</sub>)</em><li>A set of Bob’s one-time <em>curve</em> prekeys <em>(OPK<sub>B</sub><sup>1</sup>, OPK<sub>B</sub><sup>2</sup>, OPK<sub>B</sub><sup>3</sup>, …)</em> along with their identifiers <em>(IdEC(OPK<sub>B</sub><sup>1</sup>), IdEC(OPK<sub>B</sub><sup>2</sup>), IdEC(OPK<sub>B</sub><sup>3</sup>), …)</em><li>A set of Bob’s signed one-time <em>pqkem</em> prekeys <em>(PQOPK<sub>B</sub><sup>1</sup>, PQOPK<sub>B</sub><sup>2</sup>, PQOPK<sub>B</sub><sup>3</sup>, …)</em> along with their identifiers <em>(IdKEM(PQOPK<sub>B</sub><sup>1</sup>), IdKEM(PQOPK<sub>B</sub><sup>2</sup>), IdKEM(PQOPK<sub>B</sub><sup>3</sup>), …)</em><li>The set of Bob’s signatures on the signed one-time <em>pqkem</em> prekeys <em>(Sig(IK<sub>B</sub>, EncodeKEM(PQOPK<sub>B</sub><sup>1</sup>), Z<sub>1</sub>), Sig(IK<sub>B</sub>, EncodeKEM(PQOPK<sub>B</sub><sup>2</sup>), Z<sub>2</sub>), Sig(IK<sub>B</sub>, EncodeKEM(PQOPK<sub>B</sub><sup>3</sup>), Z<sub>3</sub>), …)</em></ul><p>Bob only needs to upload his identity key to the server once. However, Bob may upload new one-time prekeys at other times (e.g. when the server informs Bob that the server’s store of one-time prekeys is getting low).<p>For both the signed <em>curve</em> prekey and the signed last-resort <em>pqkem</em> prekey, Bob will upload a new prekey along with its signature using <em>IK<sub>B</sub></em> at some interval (e.g. once a week or once a month). The new signed prekey and its signatures will replace the previous values.<p>After uploading a new pair of signed <em>curve</em> and signed last-resort <em>pqkem</em> prekeys, Bob may keep the private key corresponding to the previous pair around for some period of time to handle messages using it that may have been delayed in transit. Eventually, Bob should delete this private key for forward secrecy (one-time prekey private keys will be deleted as Bob receives messages using them; see <a href="#receiving-the-initial-message">Section 3.4</a>).<h2 id="sending-the-initial-message">3.3. Sending the initial message</h2><p>To perform a PQXDH key agreement with Bob, Alice contacts the server and fetches a “prekey bundle” containing the following values:<ul><li>Bob’s <em>curve</em> identity key <em>IK<sub>B</sub></em><li>Bob’s signed <em>curve</em> prekey with its identifier <em>(SPK<sub>B</sub>, IdEC(SPK<sub>B</sub>))</em><li>Bob’s signature on the <em>curve</em> prekey <em>Sig(IK<sub>B</sub>, EncodeEC(SPK<sub>B</sub>), Z<sub>SPK</sub>)</em><li>One of either Bob’s signed one-time <em>pqkem</em> prekey <em>PQOPK<sub>B</sub><sup>n</sup></em> or Bob’s last-resort signed <em>pqkem</em> prekey <em>PQSPK<sub>B</sub></em> if no signed one-time <em>pqkem</em> prekey remains. Call this key <em>PQPK<sub>B</sub></em>. The bundle also contains <em>IdKEM(PQPK<sub>B</sub>)</em><li>Bob’s signature on the <em>pqkem</em> prekey <em>Sig(IK<sub>B</sub>, EncodeKEM(PQPK<sub>B</sub>), Z<sub>PQPK</sub>)</em><li>(Optionally) Bob’s one-time <em>curve</em> prekey <em>OPK<sub>B</sub><sup>n</sup></em> and its identifier <em>IdEC(OPK<sub>B</sub><sup>n</sup>)</em></ul><p>The server should provide one of Bob’s <em>curve</em> one-time prekeys if one exists and then delete it. If all of Bob’s <em>curve</em> one-time prekeys on the server have been deleted, the bundle will not contain a one-time <em>curve</em> prekey element.<p>The server should prefer to provide one of Bob’s <em>pqkem</em> one-time signed prekeys <em>PQOPK<sub>B</sub><sup>n</sup></em> if one exists and then delete it. If all of Bob’s <em>pqkem</em> one-time signed prekeys on the server have been deleted, the bundle will instead contain Bob’s <em>pqkem</em> last-resort signed prekey <em>PQSPK<sub>B</sub></em>.<p>Alice verifies the signatures on the prekeys. If any signature check fails, Alice aborts the protocol. Otherwise, if all signature checks pass, Alice then generates an ephemeral <em>curve</em> key pair with public key EK<sub>A</sub>. Alice additionally generates a <em>pqkem</em> encapsulated shared secret:<div class="line-block">    (CT, SS) = PQKEM-ENC(PQPK<sub>B</sub>)<br />                shared secret SS<br />                ciphertext CT</div><p>If the bundle does not contain a <em>curve</em> one-time prekey, she calculates:<div class="line-block">    DH<sub>1</sub> = DH(IK<sub>A</sub>, SPK<sub>B</sub>)<br />     DH<sub>2</sub> = DH(EK<sub>A</sub>, IK<sub>B</sub>)<br />     DH<sub>3</sub> = DH(EK<sub>A</sub>, SPK<sub>B</sub>)<br />     SK = KDF(DH<sub>1</sub> || DH<sub>2</sub> || DH<sub>3</sub> || SS)</div><p>If the bundle does contain a <em>curve</em> one-time prekey, the calculation is modified to include an additional <em>DH</em>:<div class="line-block">    DH<sub>4</sub> = DH(EK<sub>A</sub>, OPK<sub>B</sub>)<br />     SK = KDF(DH<sub>1</sub> || DH<sub>2</sub> || DH<sub>3</sub> || DH<sub>4</sub> || SS)</div><p>After calculating <em>SK</em>, Alice deletes her ephemeral private key, the <em>DH</em> outputs and the shared secret <em>SS</em>.<p>Alice then calculates an “associated data” byte sequence <em>AD</em> that contains identity information for both parties:<div class="line-block">    AD = EncodeEC(IK<sub>A</sub>) || EncodeEC(IK<sub>B</sub>)</div><p>If <em>pqkem</em> does not incorporate <em>PQPK<sub>B</sub></em> into the ciphertext, Alice must also append <em>EncodeKEM(PQPK<sub>B</sub>)</em> to <em>AD</em> (see the discussion in <a href="#preventing-kem-re-encapsulation-attacks">Section 4.12</a>). Alice may optionally append additional information to <em>AD</em>, such as Alice and Bob’s usernames, certificates, or other identifying information.<p>Alice then sends Bob an initial message containing:<ul><li>Alice’s identity key <em>IK<sub>A</sub></em><li>Alice’s ephemeral key <em>EK<sub>A</sub></em><li>The <em>pqkem</em> ciphertext <em>CT</em> encapsulating <em>SS</em> for <em>PQPK<sub>B</sub></em><li>Identifiers stating which of Bob’s prekeys Alice used<li>An initial ciphertext encrypted with some AEAD encryption scheme <span class="citation" data-cites="aead"><a href="#ref-aead" role="doc-biblioref">[5]</a></span> using <em>AD</em> as associated data and using an encryption key which is either <em>SK</em> or the output from some cryptographic PRF keyed by <em>SK</em>.</ul><p>The initial ciphertext is typically the first message in some post-PQXDH communication protocol. In other words, this ciphertext typically has two roles, serving as the first message within some post-PQXDH protocol, and as part of Alice’s PQXDH initial message.<p>The initial message must be encoded in an unambiguous format to avoid confusion of the message items by the recipient.<p>After sending this, Alice deletes the ciphertext <em>CT</em> and may continue using <em>SK</em> or keys derived from <em>SK</em> within the post-PQXDH protocol for communication with Bob, subject to the security considerations discussed in <a href="#security-considerations">Section 4</a>.<h2 id="receiving-the-initial-message">3.4. Receiving the initial message</h2><p>Upon receiving Alice’s initial message, Bob retrieves Alice’s identity key and ephemeral key from the message. Bob also loads his identity private key and uses the key identifiers to load the private key(s) corresponding to the signed prekeys, one-time prekeys, and KEM key Alice used.<p>Using these keys, Bob calculates <em>PQKEM-DEC(PQPK<sub>B</sub>, CT)</em> as the shared secret <em>SS</em> and repeats the <em>DH</em> and <em>KDF</em> calculations from the previous section to derive <em>SK</em>, and then deletes the <em>DH</em> values and <em>SS</em> values.<p>Bob then constructs the <em>AD</em> byte sequence using <em>IK<sub>A</sub></em> and <em>IK<sub>B</sub></em> as described in the previous section. Finally, Bob attempts to decrypt the initial ciphertext using <em>SK</em> and <em>AD</em>. If the initial ciphertext fails to decrypt, then Bob aborts the protocol and deletes <em>SK</em>.<p>If the initial ciphertext decrypts successfully, the protocol is complete for Bob. For forward secrecy, Bob deletes the ciphertext and any one-time prekey private key that was used. Bob may then continue using <em>SK</em> or keys derived from <em>SK</em> within the post-PQXDH protocol for communication with Alice subject to the security considerations discussed in <a href="#security-considerations">Section 4</a>.<h1 id="security-considerations">4. Security considerations</h1><p>The security of the composition of X3DH <span class="citation" data-cites="x3dh"><a href="#ref-x3dh" role="doc-biblioref">[6]</a></span> with the Double Ratchet <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span> was formally studied in <span class="citation" data-cites="CCDGS20"><a href="#ref-CCDGS20" role="doc-biblioref">[8]</a></span> and proven secure under the Gap Diffie-Hellman assumption (GapDH)<span class="citation" data-cites="OP01"><a href="#ref-OP01" role="doc-biblioref">[9]</a></span> while making simplifying assumptions that avoid modeling the reuse of <em>IK<sub>B</sub></em> for both key agreement and signing. PQXDH composed with the Double Ratchet retains this security against an adversary without access to a quantum computer, but strengthens the security of the initial handshake to require the solution of both GapDH and Module-LWE <span class="citation" data-cites="LS15"><a href="#ref-LS15" role="doc-biblioref">[10]</a></span>.<p>In <span class="citation" data-cites="pqxdh-verification"><a href="#ref-pqxdh-verification" role="doc-biblioref">[11]</a></span> PQXDH has been formally analyzed in the symbolic model with ProVerif <span class="citation" data-cites="proverif"><a href="#ref-proverif" role="doc-biblioref">[12]</a></span> and in the computational model with CryptoVerif <span class="citation" data-cites="cryptoverif"><a href="#ref-cryptoverif" role="doc-biblioref">[13]</a></span>. With ProVerif, the authors prove both authentication and secrecy in the symbolic model and enumerate the precise conditions under which the attacker can break these properties. These security properties notably imply forward secrecy, resistance to harvest now decrypt later attacks, resistance to key compromise impersonation, and session independence.<p>Using the CryptoVerif prover, the authors prove the computational secrecy and authentication of any completed key exchange under the GapDH assumption for the X25519 curve, the UF-CMA assumption on XEdDSA (assuming no key reuse between XEdDSA and X25519), the hash function modeled as a random oracle, and the IND-CPA+INT-CTXT assumptions for the AEAD. Moreover, they also show forward secrecy when the signature was UF-CMA secure at the time the key exchange took place, assuming post-quantum IND-CCA security for the KEM, modelling the hash function as a PRF, and IND-CPA+INT-CTXT security for the AEAD.<p>For both PQXDH and X3DH, however, a full proof of security under a joint assumption of GapDH and UF-CMA security for X25519 and XEdDSA is still needed.<p>The remainder of this section discusses an incomplete list of further security considerations.<h2 id="authentication">4.1. Authentication</h2><p>Before or after a PQXDH key agreement, the parties may compare their identity public keys <em>IK<sub>A</sub></em> and <em>IK<sub>B</sub></em> through some authenticated channel. For example, they may compare public key fingerprints manually, or by scanning a QR code. Methods for doing this are outside the scope of this document.<p>Authentication in PQXDH is not quantum-secure. In the presence of an active quantum adversary, the parties receive no cryptographic guarantees as to who they are communicating with. Post-quantum secure deniable mutual authentication is an open research problem which we hope to address with a future revision of this protocol.<p>If authentication is not performed, the parties receive no cryptographic guarantee as to who they are communicating with.<h2 id="protocol-replay">4.2. Protocol replay</h2><p>If Alice’s initial message doesn’t use a one-time prekey, it may be replayed to Bob and he will accept it. This could cause Bob to think Alice had sent him the same message (or messages) repeatedly.<p>To mitigate this, a post-PQXDH protocol may wish to quickly negotiate a new encryption key for Alice based on fresh random input from Bob. This is the typical behavior of Diffie-Hellman-based ratcheting protocols <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span>.<p>Bob could attempt other mitigations, such as maintaining a blacklist of observed messages, or replacing old signed prekeys more rapidly. Analyzing these mitigations is beyond the scope of this document.<h2 id="replay-and-key-reuse">4.3. Replay and key reuse</h2><p>Another consequence of the replays discussed in the previous section is that a successfully replayed initial message would cause Bob to derive the same <em>SK</em> in different protocol runs.<p>For this reason, any post-PQXDH protocol that uses <em>SK</em> to derive encryption keys MUST take measures to prevent catastrophic key reuse. For example, Bob could use a DH-based ratcheting protocol to combine <em>SK</em> with a freshly generated <em>DH</em> output to get a randomized encryption key <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span>.<h2 id="deniability">4.4. Deniability</h2><p>Informally, cryptographic deniability means that a protocol neither gives its participants a publishable cryptographic proof of the contents of their communication nor proof of the fact that they communicated. PQXDH, like X3DH, aims to provide both Alice and Bob deniablilty that they communicated with each other in a context where a “judge” who may have access to one or more party’s secret keys is presented with a transcript allegedly created by communication between Alice and Bob.<p>We focus on offline deniability because if either party is collaborating with a third party during protocol execution, they will be able to provide proof of their communication to such a third party. This limitation on “online” deniability appears to be intrinsic to the asynchronous setting <span class="citation" data-cites="unger"><a href="#ref-unger" role="doc-biblioref">[14]</a></span>.<p>PQXDH has some forms of cryptographic deniability. Motivated by the goals of X3DH, Brendel et al. <span class="citation" data-cites="bfgjs21"><a href="#ref-bfgjs21" role="doc-biblioref">[15]</a></span> introduce a notion of 1-out-of-2 deniability for semi-honest parties and a “big brother” judge with access to all parties’ secret keys. Since either Alice or Bob can create a fake transcript using only their own secret keys, PQXDH has this deniability property. Vatandas, et al. <span class="citation" data-cites="vgik21"><a href="#ref-vgik21" role="doc-biblioref">[16]</a></span> prove that X3DH is deniable in a different sense subject to certain “Knowledge of Diffie-Hellman Assumptions”. PQXDH is deniable in this sense for Alice, subject to the same assumptions, and we conjecture that it is deniable for Bob subject to an additional Plaintext Awareness (PA) assumption for <em>pqkem</em>. We note that Kyber uses a variant of the Fujisaki-Okamoto transform with implicit rejection <span class="citation" data-cites="hhk17"><a href="#ref-hhk17" role="doc-biblioref">[17]</a></span> and is therefore not PA as is. However, in PQXDH, an AEAD ciphertext encrypted with the session key is always sent along with the Kyber ciphertext. This should offer the same guarantees as PA. We encourage the community to investigate the precise deniability properties of PQXDH.<p>These assertions all pertain to deniability in the classical setting. As discussed in <span class="citation" data-cites="hkkp21"><a href="#ref-hkkp21" role="doc-biblioref">[18]</a></span> we expect that for future revisions of this protocol (that provide post-quantum mutual authentication) assertions about deniability against semi-honest quantum advsersaries will hold. Deniability in the face of malicious quantum adversaries requires further research.<h2 id="signatures">4.5. Signatures</h2><p>It might be tempting to omit the prekey signature after observing that mutual authentication and forward secrecy are achieved by the <em>DH</em> calculations. However, this would allow a “weak forward secrecy” attack: A malicious server could provide Alice a prekey bundle with forged prekeys, and later compromise Bob’s <em>IK<sub>B</sub></em> to calculate <em>SK</em>.<p>Alternatively, it might be tempting to replace the DH-based mutual authentication (i.e. <em>DH<sub>1</sub></em> and <em>DH<sub>2</sub></em>) with signatures from the identity keys. However, this reduces deniability, increases the size of initial messages, and increases the damage done if ephemeral or prekey private keys are compromised, or if the signature scheme is broken.<h2 id="key-compromise">4.6. Key compromise</h2><p>Compromise of a party’s private keys has a disastrous effect on security, though the use of ephemeral keys and prekeys provides some mitigation.<p>Compromise of a party’s identity private key allows impersonation of that party to others. Compromise of a party’s prekey private keys may affect the security of older or newer <em>SK</em> values, depending on many considerations.<p>A full analysis of all possible compromise scenarios is outside the scope of this document, however a partial analysis of some plausible scenarios is below:<ul><li><p>If either an elliptic curve one-time prekey (<em>OPK<sub>B</sub></em>) or a post-quantum key encapsulation one-time prekey (<em>PQOPK<sub>B</sub></em>) are used for a protocol run and deleted as specified, then a compromise of Bob’s identity key and prekey private keys at some future time will not compromise the older <em>SK</em>.<li><p>If one-time prekeys were not used for a protocol run, then a compromise of the private keys for <em>IK<sub>B</sub></em>, <em>SPK<sub>B</sub></em>, and <em>PQSPK<sub>B</sub></em> from that protocol run would compromise the <em>SK</em> that was calculated earlier. Frequent replacement of signed prekeys mitigates this, as does using a post-PQXDH ratcheting protocol which rapidly replaces <em>SK</em> with new keys to provide fresh forward secrecy <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span>.<li><p>Compromise of prekey private keys may enable attacks that extend into the future, such as passive calculation of <em>SK</em> values, and impersonation of arbitrary other parties to the compromised party (“key-compromise impersonation”). These attacks are possible until the compromised party replaces his compromised prekeys on the server (in the case of passive attack); or deletes his compromised signed prekey’s private key (in the case of key-compromise impersonation).</ul><h2 id="passive-quantum-adversaries">4.7. Passive quantum adversaries</h2><p>PQXDH is designed to prevent “harvest now, decrypt later” attacks by adversaries with access to a quantum computer capable of computing discrete logarithms in <em>curve</em>. While this security is primarily derived from <em>pqkem</em>, it also requires that <em>aead</em> provides post-quantum IND-CPA and INT-CTXT security. There is great uncertainty in estimating post-quantum security strength of cryptosystems, making it challenging to define this requirement precisely. Taking the NIST evaluation criteria for post-quantum cryptography submissions <span class="citation" data-cites="nist-pqc-call"><a href="#ref-nist-pqc-call" role="doc-biblioref">[19]</a></span> as a guide, it places a key-search attack on AES256 at its highest security level. While this does not correspond exactly to our security requirements, it suggests that using an appropriate AEAD mode of AES256 will suffice. We note some particular security properties of PQXDH in this setting.<ul><li><p>If an attacker has recorded the public information and the message from Alice to Bob, even access to a quantum computer will not compromise <em>SK</em>.<li><p>If a post-quantum key encapsulation one-time prekey (<em>PQOPK<sub>B</sub></em>) is used for a protocol run and deleted as specified then compromise after deletion and access to a quantum computer at some future time will not compromise the older <em>SK</em>.<li><p>If post-quantum one-time prekeys were not used for a protocol run, then access to a quantum computer and a compromise of the private key for <em>PQSPK<sub>B</sub></em> from that protocol run would compromise the <em>SK</em> that was calculated earlier. Frequent replacement of signed prekeys mitigates this, as does using a post-PQXDH ratcheting protocol which rapidly replaces <em>SK</em> with new keys to provide fresh forward secrecy <span class="citation" data-cites="doubleratchet"><a href="#ref-doubleratchet" role="doc-biblioref">[7]</a></span>.</ul><h2 id="active-quantum-adversaries">4.8. Active quantum adversaries</h2><p>PQXDH is not designed to provide protection against active quantum attackers. An active attacker with access to a quantum computer capable of computing discrete logarithms in <em>curve</em> can compute <em>DH(PK<sub>1</sub>, PK<sub>2</sub>)</em> and <em>Sig(PK, M, Z)</em> for all elliptic <em>curve</em> keys <em>PK<sub>1</sub></em>, <em>PK<sub>2</sub></em>, and <em>PK</em>. This allows an attacker to impersonate Alice by using the quantum computer to compute the secret key corresponding to <em>PK<sub>A</sub></em> then continuing with the protocol. A malicious server with access to such a quantum computer could impersonate Bob by generating new key pairs <em>PQSPK’<sub>B</sub></em> and <em>PQOPK’<sub>B</sub></em>, computing the secret key corresponding to <em>PK<sub>B</sub></em>, then using <em>PK<sub>B</sub></em> to sign the newly generated post-quantum KEM keys and delivering these attacker-generated keys in place of Bob’s post-quantum KEM key when Alice requests a prekey bundle.<p>It is tempting to consider adding a post-quantum identity key that Bob could use to sign the post-quantum prekeys. This would prevent the malicious server attack described above and provide Alice a cryptographic guarantee that she is communicating with Bob, but it does not provide mutual authentication. Bob does not have any cryptographic guarantee about who he is communicating with. The post-quantum KEM and signature schemes being standardized by NIST <span class="citation" data-cites="nistpostquantum"><a href="#ref-nistpostquantum" role="doc-biblioref">[20]</a></span> do not provide a mechanism for post-quantum deniable mutual authentication, although this can be achieved through the use of a post-quantum ring signature or designated verifier signature <span class="citation" data-cites="bfgjs21"><a href="#ref-bfgjs21" role="doc-biblioref">[15]</a></span>, <span class="citation" data-cites="hkkp21"><a href="#ref-hkkp21" role="doc-biblioref">[18]</a></span>. We urge the community to work toward standardization of these or other mechanisms that will allow deniable mutual authentication.<h2 id="server-trust">4.9. Server trust</h2><p>A malicious server could cause communication between Alice and Bob to fail (e.g. by refusing to deliver messages).<p>If Alice and Bob authenticate each other as in <a href="#authentication">Section 4.1</a>, then the only additional attack available to the server is to refuse to hand out one-time prekeys, causing forward secrecy for <em>SK</em> to depend on the signed prekey’s lifetime (as analyzed in <a href="#key-compromise">Section 4.6</a>).<p>This reduction in initial forward secrecy could also happen if one party maliciously drains another party’s one-time prekeys, so the server should attempt to prevent this (e.g. with rate limits on fetching prekey bundles).<h2 id="identity-binding">4.10. Identity binding</h2><p>Authentication as in <a href="#authentication">Section 4.1</a> does not necessarily prevent an “identity misbinding” or “unknown key share” attack.<p>This results when an attacker (“Charlie”) falsely presents Bob’s identity key fingerprint to Alice as his (Charlie’s) own, and then either forwards Alice’s initial message to Bob, or falsely presents Bob’s contact information as his own. The effect of this is that Alice thinks she is sending an initial message to Charlie when she is actually sending it to Bob.<p>To make this more difficult the parties can include more identifying information into <em>AD</em>, or hash more identifying information into the fingerprint, such as usernames, phone numbers, real names, or other identifying information. Charlie would be forced to lie about these additional values, which might be difficult.<p>However, there is no way to reliably prevent Charlie from lying about additional values, and including more identity information into the protocol often brings trade-offs in terms of privacy, flexibility, and user interface. A detailed analysis of these trade-offs is beyond the scope of this document.<h2 id="risks-of-weak-randomness-sources">4.11. Risks of weak randomness sources</h2><p>In addition to concerns about the generation of the keys themselves, the security of the PQKEM shared secret relies on the random source available to Alice’s machine at the time of running the <strong><em>PQKEM-ENC</em></strong> operation. This leads to a situation similar to what we face with a Diffie-Hellman exchange. For both Diffie-Hellman and Kyber, if Alice has weak entropy then the resulting shared secret will have low entropy when conditioned on Bob’s public key. Thus both the classical and post-quantum security of <em>SK</em> depend on the strength of Alice’s random source.<p>Kyber hashes Bob’s public key with Alice’s random bits to generate the shared secret, making Bob’s key contributory, as it is with a Diffie-Hellman key exchange. This does not reduce the dependence on Alice’s entropy source, as described above, but it does limit Alice’s ability to control the post-quantum shared secret. Not all KEMs make Bob’s key contributory and this is a property to consider when selecting <em>pqkem</em>.<h2 id="preventing-kem-re-encapsulation-attacks">4.12 Preventing KEM Re-encapsulation Attacks</h2><p>Typically, when using a KEM that relies one a public key encryption to encrypt a fresh shared secret, the fresh shared secret is not tied to the public key. A shared secret corresponding to the encapsulation of a given compromised public key can easily be re-encapsulated against another uncompromised public key. IND-CCA security of the KEM does not prevent this behavior.<p>For a KEM for which this attack is possible, as soon as one PQPK is compromised, an attacker can force all initiators to use this compromised PQPK, and by always reencapsulating the shared secret against another fresh uncompromised PQPK, make the responder believe that nothing is going awry. This notably breaks the usual notion of session independence: compromising one PQPK of a responder can in fact impact the security of other sessions of the responder that should be using distinct and independent PQPKs.<p>The Kyber KEM incorporates the KEM public key into the generation of the shared secret, preventing this attack. For a generic IND-CCA KEM, this attack can be prevented by adding <em>PQPK<sub>B</sub></em> to <em>AD</em> for the initial message. See <span class="citation" data-cites="pqxdh-verification"><a href="#ref-pqxdh-verification" role="doc-biblioref">[11]</a></span> for more details about this attack and mitigations.<h2 id="key-identifiers">4.13 Key Identifiers</h2><p>The public key identifiers are not security critical, notably as the actual values of the keys are signed or used within the AD. Note however that identifiers that would collide too often would cause decryption failures on the responder side, as the responder would try to complete the key exchange with the wrong public key, which would fail.<p>An application can choose to use public keys as key identifiers, but may choose an identifier with a smaller representation to reduce message sizes, provided that collisions are unlikely. Possible implementations include a hash of the public key, a random value, or sequentially generated values starting from a random offset.<h1 id="ipr">5. IPR</h1><p>This document is hereby placed in the public domain.<h1 id="acknowledgements">6. Acknowledgements</h1><p>The PQXDH protocol was developed by Ehren Kret and Rolfe Schmidt as an extension of the X3DH protocol <span class="citation" data-cites="x3dh"><a href="#ref-x3dh" role="doc-biblioref">[6]</a></span> by Moxie Marlinspike and Trevor Perrin. Thanks to Trevor Perrin for discussions on the design of this protocol.<p>Thanks to Bas Westerbaan, Charlie Jacomme, Chris Peikert, Daniel Collins, Deirdre Connolly, Franziskus Kiefer, John Schanck, Jon Millican, Jordan Rose, Karthik Bhargavan, Loïs Huguenin-Dumittan, Peter Schwabe, Rune Fiedler, Shuichi Katsumata, Sofía Celi, Théophile Wallez, Tomas Duchac, and Yo’av Rieck for helpful discussions and editorial feedback.<p>Thanks to the Kyber team <span class="citation" data-cites="kyberweb"><a href="#ref-kyberweb" role="doc-biblioref">[21]</a></span> for their work on the Kyber key encapsulation mechanism.<h1 class="unnumbered" id="references">7. References</h1><div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list"><div id="ref-xeddsa" class="csl-entry" role="listitem"><div class="csl-left-margin">[1]</div><div class="csl-right-inline">T. Perrin, <span>“<span class="nocase">The XEdDSA and VXEdDSA Signature Schemes</span>,”</span> 2016. <a href="https://signal.org/docs/specifications/xeddsa/">https://signal.org/docs/specifications/xeddsa/</a></div></div><div id="ref-kyberfips203" class="csl-entry" role="listitem"><div class="csl-left-margin">[2]</div><div class="csl-right-inline"><span>“Module-lattice-based key-encapsulation mechanism standard.”</span> <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.ipd.pdf">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.ipd.pdf</a></div></div><div id="ref-rfc7748" class="csl-entry" role="listitem"><div class="csl-left-margin">[3]</div><div class="csl-right-inline">A. Langley, M. Hamburg, and S. Turner, <span>“<span class="nocase">Elliptic Curves for Security</span>.”</span> Internet Engineering Task Force; RFC 7748 (Informational); IETF, Jan-2016. <a href="http://www.ietf.org/rfc/rfc7748.txt">http://www.ietf.org/rfc/rfc7748.txt</a></div></div><div id="ref-rfc5869" class="csl-entry" role="listitem"><div class="csl-left-margin">[4]</div><div class="csl-right-inline">H. Krawczyk and P. Eronen, <span>“<span class="nocase">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</span>.”</span> Internet Engineering Task Force; RFC 5869 (Informational); IETF, May-2010. <a href="http://www.ietf.org/rfc/rfc5869.txt">http://www.ietf.org/rfc/rfc5869.txt</a></div></div><div id="ref-aead" class="csl-entry" role="listitem"><div class="csl-left-margin">[5]</div><div class="csl-right-inline">P. Rogaway, <span>“<span class="nocase">Authenticated-encryption with Associated-data</span>,”</span> in <span class="nocase">Proceedings of the 9th <span>ACM</span> Conference on Computer and Communications Security</span>, 2002. <a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf">http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf</a></div></div><div id="ref-x3dh" class="csl-entry" role="listitem"><div class="csl-left-margin">[6]</div><div class="csl-right-inline">M. Marlinspike and T. Perrin, <span>“<span>The X3DH Key Agreement Protocol</span>,”</span> 2016. <a href="https://signal.org/docs/specifications/x3dh/">https://signal.org/docs/specifications/x3dh/</a></div></div><div id="ref-doubleratchet" class="csl-entry" role="listitem"><div class="csl-left-margin">[7]</div><div class="csl-right-inline">T. Perrin and M. Marlinspike, <span>“<span>The Double Ratchet Algorithm</span>,”</span> 2016. <a href="https://signal.org/docs/specifications/doubleratchet/">https://signal.org/docs/specifications/doubleratchet/</a></div></div><div id="ref-CCDGS20" class="csl-entry" role="listitem"><div class="csl-left-margin">[8]</div><div class="csl-right-inline">K. Cohn-Gordon, C. Cremers, B. Dowling, L. Garratt, and D. Stebila, <span>“A formal security analysis of the signal messaging protocol,”</span> J. Cryptol., vol. 33, no. 4, 2020. <a href="https://doi.org/10.1007/s00145-020-09360-1">https://doi.org/10.1007/s00145-020-09360-1</a></div></div><div id="ref-OP01" class="csl-entry" role="listitem"><div class="csl-left-margin">[9]</div><div class="csl-right-inline">T. Okamoto and D. Pointcheval, <span>“The gap-problems: A new class of problems for the security of cryptographic schemes,”</span> in Proceedings of the 4th international workshop on practice and theory in public key cryptography: Public key cryptography, 2001.</div></div><div id="ref-LS15" class="csl-entry" role="listitem"><div class="csl-left-margin">[10]</div><div class="csl-right-inline">A. Langlois and D. Stehlé, <span>“Worst-case to average-case reductions for module lattices,”</span> Des. Codes Cryptography, vol. 75, no. 3, Jun. 2015. <a href="https://doi.org/10.1007/s10623-014-9938-4">https://doi.org/10.1007/s10623-014-9938-4</a></div></div><div id="ref-pqxdh-verification" class="csl-entry" role="listitem"><div class="csl-left-margin">[11]</div><div class="csl-right-inline">K. Bhargavan, C. Jacomme, and F. Kiefer, <span>“PQXDH formal analysis git repository.”</span> <a href="https://github.com/Inria-Prosecco/pqxdh-analysis">https://github.com/Inria-Prosecco/pqxdh-analysis</a></div></div><div id="ref-proverif" class="csl-entry" role="listitem"><div class="csl-left-margin">[12]</div><div class="csl-right-inline"><span>“ProVerif.”</span> <a href="https://bblanche.gitlabpages.inria.fr/proverif/">https://bblanche.gitlabpages.inria.fr/proverif/</a></div></div><div id="ref-cryptoverif" class="csl-entry" role="listitem"><div class="csl-left-margin">[13]</div><div class="csl-right-inline"><span>“CryptoVerif.”</span> <a href="https://bblanche.gitlabpages.inria.fr/CryptoVerif/">https://bblanche.gitlabpages.inria.fr/CryptoVerif/</a></div></div><div id="ref-unger" class="csl-entry" role="listitem"><div class="csl-left-margin">[14]</div><div class="csl-right-inline">N. Unger and I. Goldberg, <span>“<span class="nocase">Deniable Key Exchanges for Secure Messaging</span>,”</span> in <span class="nocase">Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security</span>, 2015. <a href="https://cypherpunks.ca/~iang/pubs/dake-ccs15.pdf">https://cypherpunks.ca/~iang/pubs/dake-ccs15.pdf</a></div></div><div id="ref-bfgjs21" class="csl-entry" role="listitem"><div class="csl-left-margin">[15]</div><div class="csl-right-inline">J. Brendel, R. Fiedler, F. Günther, C. Janson, and D. Stebila, <span>“Post-quantum asynchronous deniable key exchange and the signal handshake,”</span> in Public-key cryptography - <span>PKC</span> 2022 - 25th <span>IACR</span> international conference on practice and theory of public-key cryptography, virtual event, march 8-11, 2022, proceedings, part <span>II</span>, 2022, vol. 13178. <a href="https://doi.org/10.1007/978-3-030-97131-1_1">https://doi.org/10.1007/978-3-030-97131-1_1</a></div></div><div id="ref-vgik21" class="csl-entry" role="listitem"><div class="csl-left-margin">[16]</div><div class="csl-right-inline">N. Vatandas, R. Gennaro, B. Ithurburn, and H. Krawczyk, <span>“On the cryptographic deniability of the signal protocol,”</span> in Applied cryptography and network security - 18th international conference, <span>ACNS</span> 2020, rome, italy, october 19-22, 2020, proceedings, part <span>II</span>, 2020, vol. 12147. <a href="https://doi.org/10.1007/978-3-030-57878-7_10">https://doi.org/10.1007/978-3-030-57878-7_10</a></div></div><div id="ref-hhk17" class="csl-entry" role="listitem"><div class="csl-left-margin">[17]</div><div class="csl-right-inline">D. Hofheinz, K. Hövelmanns, and E. Kiltz, <span>“A modular analysis of the fujisaki-okamoto transformation,”</span> in Theory of cryptography - 15th international conference, <span>TCC</span> 2017, baltimore, MD, USA, november 12-15, 2017, proceedings, part <span>I</span>, 2017, vol. 10677. <a href="https://doi.org/10.1007/978-3-319-70500-2_12">https://doi.org/10.1007/978-3-319-70500-2_12</a></div></div><div id="ref-hkkp21" class="csl-entry" role="listitem"><div class="csl-left-margin">[18]</div><div class="csl-right-inline">K. Hashimoto, S. Katsumata, K. Kwiatkowski, and T. Prest, <span>“An efficient and generic construction for signal’s handshake <span>(X3DH):</span> Post-quantum, state leakage secure, and deniable,”</span> J. Cryptol., vol. 35, no. 3, 2022. <a href="https://doi.org/10.1007/s00145-022-09427-1">https://doi.org/10.1007/s00145-022-09427-1</a></div></div><div id="ref-nist-pqc-call" class="csl-entry" role="listitem"><div class="csl-left-margin">[19]</div><div class="csl-right-inline">NIST, <span>“Submission requirements and evaluation criteria for the post-quantum cryptography standardization process,”</span> 2016. <a href="https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-for-proposals-final-dec-2016.pdf">https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-for-proposals-final-dec-2016.pdf</a></div></div><div id="ref-nistpostquantum" class="csl-entry" role="listitem"><div class="csl-left-margin">[20]</div><div class="csl-right-inline">NIST, <span>“Post-quantum cryptography.”</span> <a href="https://csrc.nist.gov/Projects/post-quantum-cryptography">https://csrc.nist.gov/Projects/post-quantum-cryptography</a></div></div><div id="ref-kyberweb" class="csl-entry" role="listitem"><div class="csl-left-margin">[21]</div><div class="csl-right-inline"><span>“Kyber key encapsulation mechanism.”</span> <a href="https://pq-crystals.org/kyber/">https://pq-crystals.org/kyber/</a></div></div></div></div></div><div class="columns is-centered"><div class="column is-3"></div><div class="column is-6"><h3>Want to get involved with Signal? <a href="/workworkwork/">We're hiring!</a></h3></div><div class="column is-3"></div></div></div></article></section><footer class="footer"><div class="container"><div class="columns"><div class="column is-two-fifths is-hidden-mobile"> <span class="copyright">&copy; 2013&ndash;2026 Signal, a 501c3 nonprofit.</span><br /> "Signal", Signal logos, and other trademarks are trademarks or registered trademarks of Signal Technology Foundation in the United States and other countries (<a href="/brand/">more info here</a>). <br /> <br /> For media inquiries, contact <a href="/cdn-cgi/l/email-protection#bcccced9cfcffccfd5dbd2ddd092d3cedb"><span class="__cf_email__" data-cfemail="c9b9bbacbaba89baa0aea7a8a5e7a6bbae">[email&#160;protected]</span></a></div><div class="column"> <strong>Organization</strong><ul><li> <a href="/donate/">Donate</a><li> <a href="/workworkwork/">Careers</a><li> <a href="/blog/">Blog</a><li> <a href="/brand/">Brand Assets</a><li> <a href="/legal/">Terms &amp; Privacy Policy</a></ul></div><div class="column"> <strong>Download</strong><ul><li> <a href="/download/android/">Android</a><li> <a href="/download/ios/">iPhone & iPad</a><li> <a href="/download/windows/">Windows</a><li> <a href="/download/macos/">Mac</a><li> <a href="/download/linux/">Linux</a></ul></div><div class="column"> <strong>Social</strong><ul><li> <a href="https://bsky.app/profile/signal.org" target="_blank">Bluesky</a><li> <a href="https://github.com/signalapp" target="_blank">GitHub</a><li> <a href="https://www.instagram.com/signal_app/" target="_blank">Instagram</a><li> <a href="https://mastodon.world/@signalapp" target="_blank">Mastodon</a><li> <a href="https://x.com/signalapp" target="_blank">X</a></ul></div><div class="column"> <strong>Help</strong><ul><li> <a href="https://support.signal.org">Support Center</a><li> <a href="https://community.signalusers.org/">Community</a></ul></div><div class="column is-two-fifths is-hidden-tablet"> <span class="copyright">&copy; 2013&ndash;2026 Signal, a 501c3 nonprofit.</span><br /> "Signal", Signal logos, and other trademarks are trademarks or registered trademarks of Signal Technology Foundation in the United States and other countries (<a href="/brand/">more info here</a>). <br /> <br /> For media inquiries, contact <a href="/cdn-cgi/l/email-protection#a8d8dacddbdbe8dbc1cfc6c9c486c7dacf"><span class="__cf_email__" data-cfemail="1f6f6d7a6c6c5f6c7678717e7331706d78">[email&#160;protected]</span></a></div></div></div></footer><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript" src="/assets/javascripts/vendor/jquery-3.7.1.min.js"></script> <script type="text/javascript" src="/assets/javascripts/vendor/lottie-player-2.0.3.min.js"></script> <script type="text/javascript"> document.addEventListener('DOMContentLoaded', () => { var userAgent = navigator.userAgent.toLowerCase(); var isIOS = ( userAgent.indexOf('iphone') !== -1 || userAgent.indexOf('ipad') !== -1 || userAgent.indexOf('ipod') !== -1 ); var isAndroid = userAgent.indexOf('android') !== -1; var $downloadSignal = $('.get-signal'); if (isIOS || isAndroid) { var url = isIOS ? 'https://apps.apple.com/us/app/signal-private-messenger/id874139669' : 'https://play.google.com/store/apps/details?id=org.thoughtcrime.securesms'; $downloadSignal.prop('href', url); $downloadSignal.html('<span>Get Signal</span> <i class="icon icon-external-link-alt"></i>'); } const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger')); if ($navbarBurgers.length > 0) { $navbarBurgers.forEach((el) => { el.addEventListener('click', () => { const target = el.dataset.target; const $target = document.getElementById(target); el.classList.toggle('is-active'); $target.classList.toggle('is-active'); }); }); } }); </script>
