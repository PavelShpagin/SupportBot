<!DOCTYPE html><html lang="en" data-theme="light"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content=""><meta name="author" content=""><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/blog/rss.xml" /><meta property="og:title" content="Signal Messenger: Speak Freely" /><meta property="og:site_name" content="Signal Messenger" /><meta property="og:type" content="website" /><meta property="og:description" content="Say &quot;hello&quot; to a different messaging experience. An unexpected focus on privacy, combined with all of the features you expect." /><meta property="og:url" content="https://signal.org/docs/specifications/doubleratchet/" /><meta property="og:image" content="https://signal.org/assets/images/og/og-image.png" /><meta property="og:image:width" content="1200" /><meta property="og:image:height" content="630" /><meta name="twitter:site" content="@signalapp"><meta name="twitter:card" content="app"><meta name="twitter:app:name:iphone" content="Signal"><meta name="twitter:app:id:iphone" content="874139669"><meta name="twitter:app:name:googleplay" content="Signal"><meta name="twitter:app:id:googleplay" content="org.thoughtcrime.securesms"><title>Signal >> Specifications &gt;&gt; The Double Ratchet Algorithm</title><link rel="me" href="https://mastodon.world/@signalapp"><link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/svg+xml" href="/assets/images/favicon/favicon.svg"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png"><link rel="manifest" href="/assets/images/favicon/site.webmanifest"><link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#3b45fd"><meta name="msapplication-TileColor" content="#e3e8fe"><meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml"><meta name="theme-color" content="#e3e8fe"><link rel="preload" href="/assets/fonts/inter/Inter-Regular.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="/assets/fonts/inter/Inter-ExtraBold.woff2" as="font" crossorigin="anonymous"><link type="text/css" rel="stylesheet" href="/assets/stylesheets/vendor/bulma-1.0.4.min.css"><link type="text/css" rel="stylesheet" href="/assets/stylesheets/ultramarine.css"><body id="signal" class="index has-navbar-fixed-top"><nav class="navbar signal-navbar is-fixed-top" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a href="/#signal"> <img class="signal-logo" src="/assets/images/header/logo.png"/> </a> <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="signalNavbar"> <span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span> </a></div><div id="signalNavbar" class="navbar-menu"><div class="navbar-end"> <a class="navbar-item get-signal" href="/download/">Get Signal</a> <a class="navbar-item" href="https://support.signal.org">Help</a> <a class="navbar-item" href="/blog/">Blog</a> <a class="navbar-item" href="/docs/">Developers</a> <a class="navbar-item" href="/workworkwork/">Careers</a> <a class="navbar-item" href="/donate/">Donate</a></div></div></div></nav><section id="specification" class="post"><article><div class="container content"><div class="columns is-centered"><div class="column is-8"> <img class="author" src="/assets/images/body/spaceship.png" style="margin-top: 0" /><h1 class="title text-center"> The Double Ratchet Algorithm</h1><h3 class="subtitle"><p>Revision 4, 2025-11-04 [<a href="doubleratchet.pdf">PDF</a>]<p>Trevor Perrin (editor), Moxie Marlinspike, Rolfe Schmidt (revision 3+)</h3></div></div><div class="columns is-centered"><div class="column is-8"><div id="TOC"><h2 class="toc">Table of Contents</h2><ul><li><a href="#introduction" id="toc-introduction">1. Introduction</a><li><a href="#overview" id="toc-overview">2. Overview</a><ul><li><a href="#kdf-chains" id="toc-kdf-chains">2.1. KDF chains</a><li><a href="#symmetric-key-ratchet" id="toc-symmetric-key-ratchet">2.2. Symmetric-key ratchet</a><li><a href="#diffie-hellman-ratchet" id="toc-diffie-hellman-ratchet">2.3. Diffie-Hellman ratchet</a><li><a href="#double-ratchet" id="toc-double-ratchet">2.4. Double Ratchet</a><li><a href="#out-of-order-messages" id="toc-out-of-order-messages">2.6. Out-of-order messages</a></ul><li><a href="#double-ratchet-1" id="toc-double-ratchet-1">3. Double Ratchet</a><ul><li><a href="#dr-external-functions" id="toc-dr-external-functions">3.1. External functions</a><li><a href="#state-variables" id="toc-state-variables">3.2. State variables</a><li><a href="#dr-initialization" id="toc-dr-initialization">3.3. Initialization</a><li><a href="#dr-encrypting-messages" id="toc-dr-encrypting-messages">3.4. Encrypting messages</a><li><a href="#dr-decrypting-messages" id="toc-dr-decrypting-messages">3.5. Decrypting messages</a></ul><li><a href="#double-ratchet-with-header-encryption" id="toc-double-ratchet-with-header-encryption">4. Double Ratchet with header encryption</a><ul><li><a href="#overview-1" id="toc-overview-1">4.1. Overview</a><li><a href="#external-functions" id="toc-external-functions">4.2. External functions</a><li><a href="#state-variables-1" id="toc-state-variables-1">4.3. State variables</a><li><a href="#initialization" id="toc-initialization">4.4. Initialization</a><li><a href="#encrypting-messages" id="toc-encrypting-messages">4.5. Encrypting messages</a><li><a href="#decrypting-messages" id="toc-decrypting-messages">4.6. Decrypting messages</a></ul><li><a href="#the-sparse-post-quantum-ratchet" id="toc-the-sparse-post-quantum-ratchet">5. The Sparse Post-Quantum Ratchet</a><ul><li><a href="#sparse-continuous-key-agreement" id="toc-sparse-continuous-key-agreement">5.1 Sparse Continuous Key Agreement</a><li><a href="#spqr-external-functions" id="toc-spqr-external-functions">5.2 External functions</a><li><a href="#state-variables-2" id="toc-state-variables-2">5.3 State variables</a><li><a href="#spqr-initialization" id="toc-spqr-initialization">5.4 Initialization</a><li><a href="#encrypting-messages-1" id="toc-encrypting-messages-1">5.5 Encrypting Messages</a><li><a href="#decrypting-messages-1" id="toc-decrypting-messages-1">5.6 Decrypting Messages</a><li><a href="#spqr-clearing-past-epoch-state" id="toc-spqr-clearing-past-epoch-state">5.7 Clearing past epoch state</a></ul><li><a href="#combining-double-ratchets-for-hybrid-security" id="toc-combining-double-ratchets-for-hybrid-security">6. The Triple Ratchet: combining Secure Messaging protocols for hybrid security</a><ul><li><a href="#overview-2" id="toc-overview-2">6.1 Overview</a><li><a href="#state-variables-3" id="toc-state-variables-3">6.2 State variables</a><li><a href="#tr-external-functions" id="toc-tr-external-functions">6.3 External functions</a><li><a href="#tr-initialization" id="toc-tr-initialization">6.4 Initialization</a><li><a href="#encrypting-messages-2" id="toc-encrypting-messages-2">6.5 Encrypting Messages</a><li><a href="#decrypting-messages-2" id="toc-decrypting-messages-2">6.6 Decrypting Messages</a></ul><li><a href="#implementation-considerations" id="toc-implementation-considerations">7. Implementation considerations</a><ul><li><a href="#integration-with-pqxdh" id="toc-integration-with-pqxdh">7.1. Integration with PQXDH</a><li><a href="#recommended-cryptographic-algorithms" id="toc-recommended-cryptographic-algorithms">7.2. Recommended cryptographic algorithms</a></ul><li><a href="#security-considerations" id="toc-security-considerations">8. Security considerations</a><ul><li><a href="#secure-deletion" id="toc-secure-deletion">8.1. Secure deletion</a><li><a href="#recovery-from-compromise" id="toc-recovery-from-compromise">8.2. Recovery from compromise</a><li><a href="#cryptanalysis-and-ratchet-public-keys" id="toc-cryptanalysis-and-ratchet-public-keys">8.3. Cryptanalysis and ratchet public keys</a><li><a href="#deletion-of-skipped-message-keys" id="toc-deletion-of-skipped-message-keys">8.4. Deletion of skipped message keys</a><li><a href="#deferring-new-ratchet-key-generation" id="toc-deferring-new-ratchet-key-generation">8.5. Deferring new ratchet key generation</a><li><a href="#truncating-authentication-tags" id="toc-truncating-authentication-tags">8.6. Truncating authentication tags</a><li><a href="#implementation-fingerprinting" id="toc-implementation-fingerprinting">8.7. Implementation fingerprinting</a><li><a href="#choice-of-scka-protocol" id="toc-choice-of-scka-protocol">8.8 Choice of SCKA protocol</a><li><a href="#effect-of-dropped-messages-on-pcs" id="toc-effect-of-dropped-messages-on-pcs">8.9 Effect of dropped messages on PCS</a><li><a href="#deletion-of-old-kdf-chain-state" id="toc-deletion-of-old-kdf-chain-state">8.10 Deletion of old KDF Chain state</a><li><a href="#harvest-now-decrypt-later-attacks" id="toc-harvest-now-decrypt-later-attacks">8.11 Harvest Now, Decrypt Later Attacks</a></ul><li><a href="#ipr" id="toc-ipr">9. IPR</a><li><a href="#acknowledgements" id="toc-acknowledgements">10. Acknowledgements</a><li><a href="#references" id="toc-references">9. References</a></ul></div><h1 id="introduction">1. Introduction</h1><p>The Double Ratchet algorithm is used by two parties to exchange encrypted messages based on a shared secret key. Typically the parties will use some key agreement protocol (such as PQXDH <span class="citation" data-cites="pqxdh"><a href="#ref-pqxdh" role="doc-biblioref">[1]</a></span>) to agree on the shared secret key. Following this, the parties will use the Double Ratchet to send and receive encrypted messages.<p>The parties derive new keys for every Double Ratchet message so that earlier keys cannot be calculated from later ones. The parties also send Diffie-Hellman public values attached to their messages. The results of Diffie-Hellman calculations are mixed into the derived keys so that later keys cannot be calculated from earlier ones. These properties gives some protection to earlier or later encrypted messages in case of a compromise of a party’s keys.<p>The Double Ratchet and its header encryption variant are presented below, and their security properties are discussed.<h1 id="overview">2. Overview</h1><h2 id="kdf-chains">2.1. KDF chains</h2><p>A <strong>KDF chain</strong> is a core concept in the Double Ratchet algorithm.<p>We define a <strong>KDF</strong> as a cryptographic function that takes a secret and random <strong>KDF key</strong> and some input data and returns output data. The output data is indistinguishable from random provided the key isn’t known (i.e. a KDF satisfies the requirements of a cryptographic “PRF”). If the key is not secret and random, the KDF should still provide a secure cryptographic hash of its key and input data. The HMAC and HKDF constructions, when instantiated with a secure hash algorithm, meet the KDF definition <span class="citation" data-cites="rfc2104 rfc5869"><a href="#ref-rfc2104" role="doc-biblioref">[2]</a>, <a href="#ref-rfc5869" role="doc-biblioref">[3]</a></span>.<p>We use the term <strong>KDF chain</strong> when some of the output from a KDF is used as an <strong>output key</strong> and some is used to replace the KDF key, which can then be used with another input. The below diagram represents a KDF chain processing three inputs and producing three output keys:<p><img src="Set0_0.png" alt="text" /> <p>A KDF chain has the following properties (using terminology adapted from <span class="citation" data-cites="barakhalevi"><a href="#ref-barakhalevi" role="doc-biblioref">[4]</a></span>):<ul><li><p><strong>Resilience:</strong> The output keys appear random to an adversary without knowledge of the KDF keys. This is true even if the adversary can control the KDF inputs.<li><p><strong>Forward security:</strong> Output keys from the past appear random to an adversary who learns the KDF key at some point in time.<li><p><strong>Break-in recovery:</strong> Future output keys appear random to an adversary who learns the KDF key at some point in time, provided that future inputs have added sufficient entropy.</ul><p>In a <strong>Double Ratchet session</strong> between Alice and Bob each party stores a KDF key for three chains: a <strong>root chain</strong>, a <strong>sending chain</strong>, and a <strong>receiving chain</strong> (Alice’s sending chain matches Bob’s receiving chain, and vice versa).<p>As Alice and Bob exchange messages they also exchange new Diffie-Hellman public keys, and the Diffie-Hellman output secrets become the inputs to the root chain. The output keys from the root chain become new KDF keys for the sending and receiving chains. This is called the <strong>Diffie-Hellman ratchet</strong>.<p>The sending and receiving chains advance as each message is sent and received. Their output keys are used to encrypt and decrypt messages. This is called the <strong>symmetric-key ratchet</strong><p>The next sections explain the symmetric-key and Diffie-Hellman ratchets in more detail, then show how they are combined into the Double Ratchet.<h2 id="symmetric-key-ratchet">2.2. Symmetric-key ratchet</h2><p>Every message sent or received is encrypted with a unique <strong>message key</strong>. The message keys are output keys from the sending and receiving KDF chains. The KDF keys for these chains will be called <strong>chain keys</strong>.<p>The KDF inputs for the sending and receiving chains are constant, so these chains don’t provide break-in recovery. The sending and receiving chains just ensure that each message is encrypted with a unique key that can be deleted after encryption or decryption. Calculating the next chain key and message key from a given chain key is a single <strong>ratchet step</strong> in the <strong>symmetric-key ratchet</strong>. The below diagram shows two steps:<p><img src="Set0_1.png" alt="text" /> <p>Because message keys aren’t used to derive any other keys, message keys may be stored without affecting the security of other message keys. This is useful for handling lost or out-of-order messages (see <a href="#out-of-order-messages">Section 2.6</a>).<h2 id="diffie-hellman-ratchet">2.3. Diffie-Hellman ratchet</h2><p>If an attacker steals one party’s sending and receiving chain keys, the attacker can compute all future message keys and decrypt all future messages. To prevent this, the Double Ratchet combines the symmetric-key ratchet with a <strong>DH ratchet</strong> which updates chain keys based on Diffie-Hellman outputs.<p>To implement the DH ratchet, each party generates a DH key pair (a Diffie-Hellman public key and private key) which becomes their current <strong>ratchet key pair</strong>. Every message from either party begins with a header which contains the sender’s current ratchet public key. When a new ratchet public key is received from the remote party, a <strong>DH ratchet step</strong> is performed which replaces the local party’s current ratchet key pair with a new key pair.<p>This results in a “ping-pong” behavior as the parties take turns replacing ratchet key pairs. An eavesdropper who briefly compromises one of the parties might learn the value of a current ratchet private key, but that private key will eventually be replaced with an uncompromised one. At that point, the Diffie-Hellman calculation between ratchet key pairs will define a DH output unknown to the attacker.<p>The following diagrams show how the DH ratchet derives a shared sequence of DH outputs.<p>Alice is initialized with Bob’s ratchet public key. Alice’s ratchet public key isn’t yet known to Bob. As part of initialization Alice performs a DH calculation between her ratchet private key and Bob’s ratchet public key:<p><img src="Set1_0.png" alt="text" /> <p>Alice’s initial messages advertise her ratchet public key. Once Bob receives one of these messages, Bob performs a DH ratchet step: He calculates the DH output between Alice’s ratchet public key and his ratchet private key, which equals Alice’s initial DH output. Bob then replaces his ratchet key pair and calculates a new DH output:<p><img src="Set1_1.png" alt="text" /> <p>Messages sent by Bob advertise his new public key. Eventually, Alice will receive one of Bob’s messages and perform a DH ratchet step, replacing her ratchet key pair and deriving two DH outputs, one that matches Bob’s latest and a new one:<p><img src="Set1_2.png" alt="text" /> <p>Messages sent by Alice advertise her new public key. Eventually, Bob will receive one of these messages and perform a second DH ratchet step, and so on:<p><img src="Set1_3.png" alt="text" /> <p>The DH outputs generated during each DH ratchet step are used to derive new sending and receiving chain keys. The below diagram revisits Bob’s first ratchet step. Bob uses his first DH output to derive a receiving chain that matches Alice’s sending chain. Bob uses the second DH output to derive a new sending chain:<p><img src="Set2_0.png" alt="text" /> <p>As the parties take turns performing DH ratchet steps, they take turns introducing new sending chains:<p><img src="Set2_1.png" alt="text" /> <p>However, the above picture is a simplification. Instead of taking the chain keys directly from DH outputs, the DH outputs are used as KDF inputs to a root chain, and the KDF outputs from the root chain are used as sending and receiving chain keys. Using a KDF chain here improves resilience and break-in recovery.<p>So a full DH ratchet step consists of updating the root KDF chain twice, and using the KDF output keys as new receiving and sending chain keys:<p><img src="Set2_2.png" alt="text" /> <h2 id="double-ratchet">2.4. Double Ratchet</h2><p>Combining the symmetric-key and DH ratchets gives the Double Ratchet:<ul><li><p>When a message is sent or received, a symmetric-key ratchet step is applied to the sending or receiving chain to derive the message key.<li><p>When a new ratchet public key is received, a DH ratchet step is performed prior to the symmetric-key ratchet to replace the chain keys.</ul><p>In the below diagram Alice has been initialized with Bob’s ratchet public key and a shared secret which is the initial root key. As part of initialization Alice generates a new ratchet key pair, and feeds the DH output to the root KDF to calculate a new root key (<em>RK</em>) and sending chain key (<em>CK</em>):<p><img src="Set3_0.png" alt="text" /> <p>When Alice sends her first message <em>A1</em>, she applies a symmetric-key ratchet step to her sending chain key, resulting in a new message key (message keys will be labelled with the message they encrypt or decrypt). The new chain key is stored, but the message key and old chain key can be deleted:<p><img src="Set3_1.png" alt="text" /> <p>If Alice next receives a response <em>B1</em> from Bob, it will contain a new ratchet public key (Bob’s public keys are labelled with the message when they were first received). Alice applies a DH ratchet step to derive new receiving and sending chain keys. Then she applies a symmetric-key ratchet step to the receiving chain to get the message key for the received message:<p><img src="Set3_2.png" alt="text" /> <p>Suppose Alice next sends a message <em>A2</em>, receives a message <em>B2</em> with Bob’s old ratchet public key, then sends messages <em>A3</em> and <em>A4</em>. Alice’s sending chain will ratchet three steps, and her receiving chain will ratchet once:<p><img src="Set3_3.png" alt="text" /> <p>Suppose Alice then receives messages <em>B3</em> and <em>B4</em> with Bob’s next ratchet key, then sends a message <em>A5</em>. Alice’s final state will be as follows:<p><img src="Set3_4.png" alt="text" /> <h2 id="out-of-order-messages">2.6. Out-of-order messages</h2><p>The Double Ratchet handles lost or out-of-order messages by including in each message header the message’s number in the sending chain (<em>N</em>=0,1,2,…) and the length (number of message keys) in the previous sending chain (<em>PN</em>). This enables the recipient to advance to the relevant message key while storing skipped message keys in case the skipped messages arrive later.<p>On receiving a message, if a DH ratchet step is triggered then the received <em>PN</em> minus the length of the current receiving chain is the number of skipped messages in that receiving chain. The received <em>N</em> is the number of skipped messages in the new receiving chain (i.e. the chain after the DH ratchet).<p>If a DH ratchet step isn’t triggered, then the received <em>N</em> minus the length of the receiving chain is the number of skipped messages in that chain.<p>For example, consider the message sequence from the previous section when messages <em>B2</em> and <em>B3</em> are skipped. Message <em>B4</em> will trigger Alice’s DH ratchet step (instead of <em>B3</em>). Message <em>B4</em> will have <em>PN</em>=2 and <em>N</em>=1. On receiving <em>B4</em> Alice will have a receiving chain of length 1 (<em>B1</em>), so Alice will store message keys for <em>B2</em> and <em>B3</em> so they can be decrypted if they arrive later:<p><img src="Set3_5.png" alt="text" /> <h1 id="double-ratchet-1">3. Double Ratchet</h1><h2 id="dr-external-functions">3.1. External functions</h2><p>To instantiate the Double Ratchet requires defining the following functions. For recommendations, see <a href="#recommended-cryptographic-algorithms">Section 7.2</a>.<ul><li><p><strong><em>GENERATE_DH()</em></strong>: Returns a new Diffie-Hellman key pair.<li><p><strong><em>DH(dh_pair, dh_pub)</em></strong>: Returns the output from the Diffie-Hellman calculation between the private key from the DH key pair <em>dh_pair</em> and the DH public key <em>dh_pub</em>. If the DH function rejects invalid public keys, then this function may raise an exception which terminates processing.<li><p><strong><em>KDF_RK(rk, dh_out)</em></strong>: Returns a pair (32-byte root key, 32-byte chain key) as the output of applying a KDF keyed by a 32-byte root key <em>rk</em> to a Diffie-Hellman output <em>dh_out</em>.<li><p><strong><em>KDF_CK(ck)</em></strong>: Returns a pair (32-byte chain key, 32-byte message key) as the output of applying a KDF keyed by a 32-byte chain key <em>ck</em> to some constant. If <em>ck</em> is <em>None</em> this function must fail in a way that terminates processing.<li><p><strong><em>ENCRYPT(mk, plaintext, associated_data)</em></strong>: Returns an AEAD encryption of <em>plaintext</em> with message key <em>mk</em> <span class="citation" data-cites="aead"><a href="#ref-aead" role="doc-biblioref">[5]</a></span>. The <em>associated_data</em> is authenticated but is not included in the ciphertext. Because each message key is only used once, the AEAD nonce may handled in several ways: fixed to a constant; derived from <em>mk</em> alongside an independent AEAD encryption key; derived as an additional output from <em>KDF_CK()</em>; or chosen randomly and transmitted.<li><p><strong><em>DECRYPT(mk, ciphertext, associated_data)</em></strong>: Returns the AEAD decryption of <em>ciphertext</em> with message key <em>mk</em>. If authentication fails, an exception will be raised that terminates processing.<li><p><strong><em>HEADER(dh_pair, pn, n)</em></strong>: Creates a new message header containing the DH ratchet public key from the key pair in <em>dh_pair</em>, the previous chain length <em>pn</em>, and the message number <em>n</em>. The returned header object contains ratchet public key <em>dh</em> and integers <em>pn</em> and <em>n</em> and must ensure that <em>dh</em> is not <em>None</em>.<li><p><strong><em>CONCAT(ad, header)</em></strong>: Encodes a message header into a parseable byte sequence, prepends the <em>ad</em> byte sequence, and returns the result. If <em>ad</em> is not guaranteed to be a parseable byte sequence, a length value should be prepended to the output to ensure that the output is parseable as a unique pair (<em>ad</em>, <em>header</em>).</ul><p>A <strong><em>MAX_SKIP</em></strong> constant also needs to be defined. This specifies the maximum number of message keys that can be skipped in a single chain. It should be set high enough to tolerate routine lost or delayed messages, but low enough that a malicious sender can’t trigger excessive recipient computation.<h2 id="state-variables">3.2. State variables</h2><p>The following state variables are tracked by each party:<ul><li><p><strong><em>DHs</em></strong>: DH Ratchet key pair (the “sending” or “self” ratchet key)<li><p><strong><em>DHr</em></strong>: DH Ratchet public key (the “received” or “remote” key)<li><p><strong><em>RK</em></strong>: 32-byte Root Key<li><p><strong><em>CKs, CKr</em></strong>: 32-byte Chain Keys for sending and receiving<li><p><strong><em>Ns, Nr</em></strong>: Message numbers for sending and receiving<li><p><strong><em>PN</em></strong>: Number of messages in previous sending chain<li><p><strong><em>MKSKIPPED</em></strong>: Dictionary of skipped-over message keys, indexed by ratchet public key and message number. Raises an exception if too many elements are stored.</ul><p>In the Python code that follows, the state variables are accessed as members of a <strong><em>state</em></strong> object.<h2 id="dr-initialization">3.3. Initialization</h2><p>Prior to initialization both parties must use some key agreement protocol to agree on a 32-byte shared secret key <em>SK</em> and Bob’s ratchet public key. These values will be used to populate Alice’s sending chain key and Bob’s root key. Bob’s chain keys and Alice’s receiving chain key will be left empty, since they are populated by each party’s first DH ratchet step.<p>(This assumes Alice begins sending messages first, and Bob doesn’t send messages until he has received one of Alice’s messages. To allow Bob to send messages immediately after initialization Bob’s sending chain key and Alice’s receiving chain key could be initialized to a shared secret. For the sake of simplicity we won’t consider this further.)<p>Once Alice and Bob have agreed on <em>SK</em> and Bob’s ratchet public key, Alice calls <em>RatchetInitAlice()</em> and Bob calls <em>RatchetInitBob()</em>:<pre><code>def RatchetInitAlice(state, SK, bob_dh_public_key):
    state.DHs = GENERATE_DH()
    state.DHr = bob_dh_public_key
    state.RK, state.CKs = KDF_RK(SK, DH(state.DHs, state.DHr))
    state.CKr = None
    state.Ns = 0
    state.Nr = 0
    state.PN = 0
    state.MKSKIPPED = {}

def RatchetInitBob(state, SK, bob_dh_key_pair):
    state.DHs = bob_dh_key_pair
    state.DHr = None
    state.RK = SK
    state.CKs = None
    state.CKr = None
    state.Ns = 0
    state.Nr = 0
    state.PN = 0
    state.MKSKIPPED = {}</code></pre><h2 id="dr-encrypting-messages">3.4. Encrypting messages</h2><p><em>RatchetEncrypt()</em> is called to encrypt messages. This function performs a symmetric-key ratchet step, then encrypts the message with the resulting message key. In addition to the message’s <em>plaintext</em> it takes an <em>AD</em> byte sequence which is prepended to the header to form the associated data for the underlying AEAD encryption:<pre><code>def RatchetSendKey(state):
    state.CKs, mk = KDF_CK(state.CKs)
    Ns = state.Ns
    state.Ns += 1
    return Ns, mk

def RatchetEncrypt(state, plaintext, AD):
    Ns, mk = RatchetSendKey(state)
    header = HEADER(state.DHs, state.PN, Ns)
    return header, ENCRYPT(mk, plaintext, CONCAT(AD, header))</code></pre><h2 id="dr-decrypting-messages">3.5. Decrypting messages</h2><p><em>RatchetDecrypt()</em> is called to decrypt messages. This function does the following:<ul><li><p>If the message corresponds to a skipped message key this function decrypts the message, deletes the message key, and returns.<li><p>Otherwise, if a new ratchet key has been received this function stores any skipped message keys from the receiving chain and performs a DH ratchet step to replace the sending and receiving chains.<li><p>This function then stores any skipped message keys from the current receiving chain, performs a symmetric-key ratchet step to derive the relevant message key and next chain key, and decrypts the message.</ul><p>If an exception is raised (e.g. message authentication failure) then the message is discarded and changes to the state object are discarded. Otherwise, the decrypted plaintext is accepted and changes to the state object are stored:<p> <pre><code>def RatchetReceiveKey(state, header):
    mk = TrySkippedMessageKeys(state, header)
    if mk != None:
        return mk
    if header.dh != state.DHr:
        SkipMessageKeys(state, header.pn)
        DHRatchet(state, header)
    SkipMessageKeys(state, header.n)
    state.CKr, mk = KDF_CK(state.CKr)
    state.Nr += 1
    return mk

def RatchetDecrypt(state, header, ciphertext, AD):
    mk = RatchetReceiveKey(state, header)
    return DECRYPT(mk, ciphertext, CONCAT(AD, header))

def TrySkippedMessageKeys(state, header):
    if (header.dh, header.n) in state.MKSKIPPED:
        mk = state.MKSKIPPED[header.dh, header.n]
        del state.MKSKIPPED[header.dh, header.n]
        return mk
    else:
        return None

def SkipMessageKeys(state, until):
    if state.Nr + MAX_SKIP &lt; until:
        raise Error()
    if state.CKr != None:
        while state.Nr &lt; until:
            state.CKr, mk = KDF_CK(state.CKr)
            state.MKSKIPPED[state.DHr, state.Nr] = mk
            state.Nr += 1

def DHRatchet(state, header):
    state.PN = state.Ns
    state.Ns = 0
    state.Nr = 0
    state.DHr = header.dh
    state.RK, state.CKr = KDF_RK(state.RK, DH(state.DHs, state.DHr))
    state.DHs = GENERATE_DH()
    state.RK, state.CKs = KDF_RK(state.RK, DH(state.DHs, state.DHr))</code></pre><h1 id="double-ratchet-with-header-encryption">4. Double Ratchet with header encryption</h1><h2 id="overview-1">4.1. Overview</h2><p>This section describes the <strong>header encryption</strong> variant of the Double Ratchet.<p>Message headers contain ratchet public keys and (<em>PN</em>, <em>N</em>) values. In some cases it may be desirable to encrypt the headers so that an eavesdropper can’t tell which messages belong to which sessions, or the ordering of messages within a session.<p>With header encryption each party stores a symmetric <strong>header key</strong> and <strong>next header key</strong> for both the sending and receiving directions. The sending header key is used for encrypting headers for the current sending chain.<p>When a recipient receives a message she must first associate the message with its relevant Double Ratchet session (assuming she has different sessions with different parties). How this is done is outside of the scope of this document, although the Pond protocol offers some ideas <span class="citation" data-cites="pond2"><a href="#ref-pond2" role="doc-biblioref">[6]</a></span>.<p>After associating the message with a session, the recipient attempts to decrypt the header with that session’s receiving header key, next header key, and any header keys corresponding to skipped messages. Successful decryption with the next header key indicates the recipient must perform a DH ratchet step. During a DH ratchet step the next header keys replace the current header keys, and new next header keys are taken as additional output from the root KDF.<p>In the below diagram Alice has been initialized with Bob’s ratchet public key and shared secrets for the initial root key, the sending header key (<em>HK</em>), and the receiving next header key (<em>NHK</em>). As part of initialization Alice generates her ratchet key pair and updates the root chain to derive a new root key, sending chain key, and sending next header key (<em>NHK</em>):<p><img src="Set4_0.png" alt="text" /> <p>When Alice sends her first message <em>A1</em>, she encrypts its header with the sending header key she was initialized with:<p><img src="Set4_1.png" alt="text" /> <p>If Alice next receives a response B1 from Bob, its header will be encrypted with the receiving next header key that she was initialized with. Alice applies a DH ratchet step which shifts the next header keys into the current header keys, and generates new next header keys:<p><img src="Set4_2.png" alt="text" /> <p>Alice next sends a message <em>A2</em>, then receives a message <em>B2</em> using the current receiving header key and containing the same ratchet public key she received in message <em>B1</em>. Alice then sends messages <em>A3</em> and <em>A4</em>. The current header keys are used for all sent and received messages:<p><img src="Set4_3.png" alt="text" /> <p>Alice then receives message <em>B3</em> containing Bob’s next ratchet key and with its header encrypted by the next receiving header key. Successful header decryption with the next header key will trigger a DH ratchet step. Alice then receives <em>B4</em> with the same ratchet key and header key, then sends a message <em>A5</em>. Alice’s final state will be as follows:<p><img src="Set4_4.png" alt="text" /> <h2 id="external-functions">4.2. External functions</h2><p>Additional functions are required for header encryption:<ul><li><p><strong><em>HENCRYPT(hk, plaintext)</em></strong>: Returns the AEAD encryption of <em>plaintext</em> with header key <em>hk</em>. Because the same <em>hk</em> will be used repeatedly, the AEAD nonce must either be a stateful non-repeating value, or must be a random non-repeating value chosen with at least 128 bits of entropy.<li><p><strong><em>HDECRYPT(hk, ciphertext)</em></strong>: Returns the authenticated decryption of <em>ciphertext</em> with header key <em>hk</em>. If authentication fails, or if the header key <em>hk</em> is empty (<em>None</em>), returns <em>None</em>.<li><p><strong><em>KDF_RK_HE(rk, dh_out)</em></strong>: Returns a new root key, chain key, and next header key as the output of applying a KDF keyed by root key <em>rk</em> to a Diffie-Hellman output <em>dh_out</em>.</ul><h2 id="state-variables-1">4.3. State variables</h2><p>Additional state variables are required:<ul><li><strong><em>HKs, HKr</em></strong>: 32-byte Header Keys for sending and receiving<li><strong><em>NHKs, NHKr</em></strong>: 32-byte Next Header Keys for sending and receiving</ul><p>The following variable’s definition is changed:<ul><li><strong><em>MKSKIPPED</em></strong>: Dictionary of skipped-over message keys, indexed by header key and message number. Raises an exception if too many elements are stored.</ul><h2 id="initialization">4.4. Initialization</h2><p>Some additional shared secrets must be used to initialize the header keys:<ul><li><p>Alice’s sending header key and Bob’s next receiving header key must be set to the same value, so that Alice’s first message triggers a DH ratchet step for Bob.<li><p>Alice’s next receiving header key and Bob’s next sending header key must be set to the same value, so that after Bob’s first DH ratchet step, Bob’s next message triggers a DH ratchet step for Alice.</ul><p>Once Alice and Bob have agreed on <em>SK</em>, Bob’s ratchet public key, and these additional values, Alice calls <em>RatchetInitAliceHE()</em> and Bob calls <em>RatchetInitBobHE()</em>:<p> <pre><code>def RatchetInitAliceHE(state, SK, bob_dh_public_key, shared_hka, shared_nhkb):
    state.DHRs = GENERATE_DH()
    state.DHRr = bob_dh_public_key
    state.RK, state.CKs, state.NHKs = KDF_RK_HE(SK, DH(state.DHRs, state.DHRr))
    state.CKr = None
    state.Ns = 0
    state.Nr = 0
    state.PN = 0
    state.MKSKIPPED = {}
    state.HKs = shared_hka
    state.HKr = None
    state.NHKr = shared_nhkb

def RatchetInitBobHE(state, SK, bob_dh_key_pair, shared_hka, shared_nhkb):
    state.DHRs = bob_dh_key_pair
    state.DHRr = None
    state.RK = SK
    state.CKs = None
    state.CKr = None
    state.Ns = 0
    state.Nr = 0
    state.PN = 0
    state.MKSKIPPED = {}
    state.HKs = None
    state.NHKs = shared_nhkb
    state.HKr = None
    state.NHKr = shared_hka</code></pre><h2 id="encrypting-messages">4.5. Encrypting messages</h2><p>The <em>RatchetEncryptHE()</em> function is called to encrypt messages with header encryption:<pre><code>def RatchetEncryptHE(state, plaintext, AD):
    state.CKs, mk = KDF_CK(state.CKs)
    header = HEADER(state.DHRs, state.PN, state.Ns)
    enc_header = HENCRYPT(state.HKs, header)
    state.Ns += 1
    return enc_header, ENCRYPT(mk, plaintext, CONCAT(AD, enc_header))</code></pre><h2 id="decrypting-messages">4.6. Decrypting messages</h2><p><em>RatchetDecryptHE()</em> is called to decrypt messages with header encryption:<pre><code>def RatchetDecryptHE(state, enc_header, ciphertext, AD):
    plaintext = TrySkippedMessageKeysHE(state, enc_header, ciphertext, AD)
    if plaintext != None:
        return plaintext
    header, dh_ratchet = DecryptHeader(state, enc_header)
    if dh_ratchet:
        SkipMessageKeysHE(state, header.pn)
        DHRatchetHE(state, header)
    SkipMessageKeysHE(state, header.n)
    state.CKr, mk = KDF_CK(state.CKr)
    state.Nr += 1
    return DECRYPT(mk, ciphertext, CONCAT(AD, enc_header))

def TrySkippedMessageKeysHE(state, enc_header, ciphertext, AD):
    for ((hk, n), mk) in state.MKSKIPPED.items():
        header = HDECRYPT(hk, enc_header)
        if header != None and header.n == n:
            del state.MKSKIPPED[hk, n]
            return DECRYPT(mk, ciphertext, CONCAT(AD, enc_header))
    return None

def DecryptHeader(state, enc_header):
    header = HDECRYPT(state.HKr, enc_header)
    if header != None:
        return header, False
    header = HDECRYPT(state.NHKr, enc_header)
    if header != None:
        return header, True
    raise Error()

def SkipMessageKeysHE(state, until):
    if state.Nr + MAX_SKIP &lt; until:
        raise Error()
    if state.CKr != None:
        while state.Nr &lt; until:
            state.CKr, mk = KDF_CK(state.CKr)
            state.MKSKIPPED[state.HKr, state.Nr] = mk
            state.Nr += 1</code></pre><p> <pre><code>def DHRatchetHE(state, header):
    state.PN = state.Ns
    state.Ns = 0
    state.Nr = 0
    state.HKs = state.NHKs
    state.HKr = state.NHKr
    state.DHRr = header.dh
    state.RK, state.CKr, state.NHKr = KDF_RK_HE(state.RK, DH(state.DHRs, state.DHRr))
    state.DHRs = GENERATE_DH()
    state.RK, state.CKs, state.NHKs = KDF_RK_HE(state.RK, DH(state.DHRs, state.DHRr))</code></pre><h1 id="the-sparse-post-quantum-ratchet">5. The Sparse Post-Quantum Ratchet</h1><p>This section describes the <em>Sparse Post-Quantum Ratchet protocol</em>, a secure messaging protocol built on a Sparse Continuous Key Agreement (SCKA) protocol.<p>The Double Ratchet protocol described above does not provide security against attacks using cryptographically relevant quantum computers. For applications without bandwidth constraints, <span class="citation" data-cites="ACD19"><a href="#ref-ACD19" role="doc-biblioref">[7]</a></span> shows a way to generalize the Double Ratchet protocol presented above to use what is called a <em>Continuous Key Agreement</em> (CKA) protocol. Informally, a CKA is a protocol that sends messages back and forth between Alice and Bob in a way that a new shared key is generated with each message. For example, the Double Ratchet protocol from Section 3 corresponds to a CKA where parties send fresh ephemeral keys with each message, and the output key after any round is the Diffie-Hellman key agreement the ephemeral keys exchanged in the previous two rounds (which can be efficiently computed by both Alice and Bob). Moreover, it is easy to construct post-quantum secure CKA protocols — and hence get a post-quantum secure variant of the Double Ratchet protocol — using any post-quantum secure Key Encapsulation Mechanism (KEM), such as ML-KEM. While this is elegant, existing post-quantum KEMs require exchanging messages that are orders of magnitude larger than elliptic curve keys, which can be impractical for bandwidth-limited applications.<p>To address this issue and enable robust, quantum-safe ratcheting protocols in a bandwidth-limited environment, Sparse Continuous Key Agreement (SCKA) protocols have been introduced by <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[8]</a></span>. Just like CKA protocols, SCKA protocols allow two parties to regularly produce shared secrets. However, one drops the requirement that fresh shared keys are produced with each message, as well as insistence that the parties alternate their messages. This allows one to design natural, post-quantum secure SCKA protocols in an environment with bandwidth limits <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[8]</a></span>, as one no longer needs to transmit full post-quantum key exchange messages in every single application message. We describe the syntax and intuitive security of SCKA in Section 5.1, leaving the actual design of a suitable post-quantum SCKA (called the ML-KEM Braid protocol) in a companion document <span class="citation" data-cites="mlkembraid"><a href="#ref-mlkembraid" role="doc-biblioref">[9]</a></span>.<p>In the remainder of Section 5 we present the details of <em>Sparse Post-Quantum Ratchet</em>, a secure messaging protocol built generically from any SCKA protocol. Intuitively, the generalized protocol will only create new sender and receiver chains when the SCKA produces a new secret. As a subtlety, it will need to create both a sender chain and a receiver chain with this new secret, as both parties might exchange application messages during the time in between successive SCKA secret generations. Moreover, in addition to post-quantum security and good bandwidth usage, it will inherit security properties similar to the original Double Ratchet protocol. Intuitively, when using the ML-KEM Braid as the SCKA protocol, this Sparse Post-Quantum Ratchet gains post-quantum security, but more messages must be exchanged to attain post-compromise security.<h2 id="sparse-continuous-key-agreement">5.1 Sparse Continuous Key Agreement</h2><p>SCKA is defined formally in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[8]</a></span> and a high-level description is available in <span class="citation" data-cites="mlkembraid"><a href="#ref-mlkembraid" role="doc-biblioref">[9]</a></span>.<p>An SCKA protocol provides two functions that output shared secrets. These shared secrets are identified by ordered “epoch identifiers”, and the SCKA functions output epoch information needed to use these secrets correctly:<ul><li><strong>SCKAInitAlice(sk) → state</strong>: Initialize Alice’s state using an initial shared secret <em>sk</em>.<li><strong>SCKAInitBob(sk) → state</strong>: Initialize Bob’s state using an initial shared secret <em>sk</em>.<li><strong>SCKASend(state) → (msg, sending_epoch, output_key)</strong><ul><li><strong>msg</strong>: Opaque message data for the SCKA protocol<li><strong>sending_epoch</strong>: Latest epoch guaranteed known by receiver after processing <em>msg</em><li><strong>output_key</strong>: Either None or <em>(key_epoch, key)</em> where <em>key_epoch</em> identifies the epoch of <em>key</em></ul><li><strong>SCKAReceive(state, msg) → (receiving_epoch, output_key)</strong>:<ul><li><strong>msg</strong>: Opaque message data for the SCKA protocol<li><strong>receiving_epoch</strong>: Epoch emitted as <em>sending_epoch</em> when sender generated <em>msg</em><li><strong>output_key</strong>: Either None or <em>(key_epoch, key)</em> where <em>key_epoch</em> identifies the epoch of <em>key</em></ul></ul><p>The Sparse Post-Quantum Ratchet is a natural adaptation of the Elliptic Curve Double Ratchet to the SCKA setting. Instead of sending Elliptic Curve public keys with each application message, we send the message output by a call to <em>SCKASend()</em>. Whenever <em>SCKASend()</em> or <em>SCKAReceive()</em> return a non-null <em>key</em>, we mix this with our root key to create a new root key as well as a new sender KDF chain and receiver KDF chain for this new epoch.<p>When encrypting a message we use the <em>sending_epoch</em> returned by <em>SCKASend()</em> to look up the correct sending chain to use and we compute a message key from that KDF chain. The SCKA protocol guarantees that the <em>sending_epoch</em> will be the latest epoch known by the sender that will also be known by the receiver after processing <em>msg</em>.<p>Similarly, when receiving a message, we use the <em>receiving_epoch</em> returned by <em>SCKAReceive()</em> to look up the needed receiver chain, and retrieve or compute a message key from that KDF chain. The SCKA protocol guarantees that the receiving party will know the secret for <em>receiving_epoch</em> once <em>msg</em> is processed and that the call to <em>SCKASend()</em> that generated <em>msg</em> output <em>sending_epoch</em> with <em>sending_epoch == receiving_epoch</em>.<h2 id="spqr-external-functions">5.2 External functions</h2><ul><li><p><strong><em>KDF_SCKA_INIT(sk)</em></strong>: Returns a triple (32-byte root key, 32-byte sender chain key, 32-byte receiver chain key) as the output of applying a KDF keyed by a 32-byte secret <em>sk</em> to some unique constant specifying the protocol in use and its parameters.<li><p><strong><em>KDF_SCKA_RK(rk, scka_output)</em></strong>: Returns a triple (32-byte root key, 32-byte sender chain key, 32-byte receiver chain key) as the output of applying a KDF keyed by a 32-byte root key <em>rk</em> to a key output by the SCKA protocol.<li><p><strong><em>KDF_SCKA_CK(ck, ctr)</em></strong>: Returns a pair (32-byte chain key, 32-byte message key) as the output of applying a KDF keyed by a 32-byte chain key <em>ck</em> to <em>ctr</em> concatenated with some unique constant specifying the protocol in use and its parameters.<li><p><strong><em>KDFChain(ck)</em></strong>: Initializes a KDF Chain with chain key <em>CK = ck</em> and counter <em>N = 0</em>.</ul><h2 id="state-variables-2">5.3 State variables</h2><ul><li><strong>RK</strong>: a 32-byte root key.<li><strong>epoch</strong>: The latest epoch for which SCKA keys have been incorporated.<li><strong>kdfchains</strong>: a table indexed by epoch with values containing two KDF chains: <em>send</em> and <em>receive</em>.<li><strong>MKSKIPPED</strong>: a map from epoch to a map of message numbers to skipped message keys.<li><strong>direction</strong>: A flag indicating the role the participant plays in the protocol, one of <em>A2B</em> or <em>B2A</em>.<li><strong>scka_state</strong>: the opaque state of an SCKA protocol.</ul><h2 id="spqr-initialization">5.4 Initialization</h2><p>Prior to initialization both parties must use some key agreement protocol to agree on a 32-byte shared secret key <em>SK</em>. This value will be used to populate Alice and Bob’s initial <em>RK</em> and KDF chains, as well as to initialize the SCKA state.<pre><code>def RatchetInitAliceSCKA(state, SK):
  state.scka_state = SCKAInitAlice(SK)
  state.direction = A2B
  state.RK, CKs, CKr = KDF_SCKA_INIT(SK)
  state.epoch = 0
  state.kdfchains = {}
  state.kdfchains[0] = {}
  state.MKSKIPPED = {}
  state.kdfchains[0].send = KDFChain(CKs)
  state.kdfchains[0].receive = KDFChain(CKr)

def RatchetInitBobSCKA(state, SK):
  state.scka_state = SCKAInitBob(SK)
  state.direction = B2A
  state.RK, CKr, CKs = KDF_SCKA_INIT(SK) # note the reordering of CKs and CKr
  state.epoch = 0
  state.kdfchains = {}
  state.kdfchains[0] = {}
  state.MKSKIPPED = {}
  state.kdfchains[0].send = KDFChain(CKs)
  state.kdfchains[0].receive = KDFChain(CKr)</code></pre><h2 id="encrypting-messages-1">5.5 Encrypting Messages</h2><p>Since the SCKA may output a new shared secret when sending a message, the protocol may need to advance the public ratchet when computing the message key used to encrypt an outgoing message. Otherwise, Sparse Post-Quantum Ratchet encryption is similar to Double Ratchet encryption.<pre><code>def SCKARatchetSendKey(state):
    msg, sending_epoch, output_key = SCKASend(state.scka_state)
    if output_key != None:
        key_epoch, key = output_key
        # Advance to new epoch
        assert state.epoch + 1 == key_epoch
        state.RK, CKs, CKr = KDF_SCKA_RK(state.RK, key)
        if state.direction == B2A:
            (CKs, CKr) = (CKr, CKs)

        # Create new chains
        state.kdfchains[key_epoch] = {
            &#39;send&#39;: KDFChain(CKs),
            &#39;receive&#39;: KDFChain(CKr)
        }
        state.epoch = key_epoch
        ClearOldEpochs(state, sending_epoch)

    # Continue with message key derivation
    state.kdfchains[sending_epoch - 1].send = None
    state.kdfchains[sending_epoch].send.N += 1
    state.kdfchains[sending_epoch].send.CK, mk
        = KDF_SCKA_CK(state.kdfchains[sending_epoch].send.CK, state.kdfchains[sending_epoch].send.N)
    return msg, state.kdfchains[sending_epoch].send.N, mk

def SCKARatchetEncrypt(state, plaintext, AD):
    msg, n, mk = SCKARatchetSendKey(state)
    header = SCKA_HEADER(msg, n)
    return header, ENCRYPT(mk, plaintext, CONCAT(AD, header))

def ClearOldEpochs(state, sending_epoch):
    state.kdfchains[sending_epoch - 2] = None
    state.MKSKIPPED[sending_epoch - 2] = None</code></pre><h2 id="decrypting-messages-1">5.6 Decrypting Messages</h2><p>When receiving a message, the SCKA protocol takes the place of <em>DHRatchet()</em> in the Double Ratchet. When the SCKA emits a new shared key, it is used to advance the root key and create sender and receiver KDF chains for the new epoch.<pre><code>def SCKARatchetReceiveKey(state, header):
    receiving_epoch, output_key = SCKAReceive(state.scka_state, header.msg)
    if output_key != None:
        key_epoch, key = output_key
        assert state.epoch + 1 == key_epoch
        state.RK, CKs, CKr = KDF_SCKA_RK(state.RK, key)
        if state.direction == B2A:
            (CKs, CKr) = (CKr, CKs)

        # Create new chains
        state.kdfchains[key_epoch] = {
            &#39;send&#39;: KDFChain(CKs),
            &#39;receive&#39;: KDFChain(CKr)
        }
        state.epoch = key_epoch

    # Continue with message key derivation
    mk = TrySkippedMessageKeys(state, receiving_epoch, header.n)
    if mk != None:
        return mk
    SkipMessageKeys(state, receiving_epoch, header.n)
    state.kdfchains[receiving_epoch].receive.N += 1
    state.kdfchains[receiving_epoch].receive.CK, mk
        = KDF_SCKA_CK(
              state.kdfchains[receiving_epoch].receive.CK,
              state.kdfchains[receiving_epoch].receive.N)
    return mk

def SCKARatchetDecrypt(state, header, ciphertext, AD):
    mk = SCKARatchetReceiveKey(state, header)
    return DECRYPT(mk, ciphertext, CONCAT(AD, header))

def TrySkippedMessageKeys(state, key_epoch, n):
    if key_epoch in state.MKSKIPPED and n in state.MKSKIPPED[key_epoch]:
        mk = state.MKSKIPPED[key_epoch][n]
        del state.MKSKIPPED[key_epoch][n]
        if len(state.MKSKIPPED[key_epoch]) == 0:
            del state.MKSKIPPED[key_epoch]
        return mk
    else:
        return None

def SkipMessageKeys(state, epoch, until):
    if state.kdfchains[epoch].receive == None:
        return
    if state.kdfchains[epoch].receive.N + MAX_SKIP &lt; until:
        raise Error()
    while state.kdfchains[epoch].receive.N &lt; until:
        state.kdfchains[epoch].receive.N += 1
        state.kdfchains[epoch].receive.CK, mk
            = KDF_SCKA_CK(state.kdfchains[epoch].receive.CK, state.kdfchains[epoch].receive.N)
        if epoch not in state.MKSKIPPED:
            state.MKSKIPPED[epoch] = {}
        state.MKSKIPPED[epoch][state.kdfchains[epoch].receive.N] = mk</code></pre><h2 id="spqr-clearing-past-epoch-state">5.7 Clearing past epoch state</h2><p>The Sparse Post-Quantum Ratchet clears old KDF Chain state by calling the function <em>ClearOldEpochs(state, epoch)</em> to ensure that the state only stores the KDF Chains for two epochs at any time. Note that this function <em>also</em> clears the keys stored in <em>MKSKIPPED</em> for older epochs, limiting a receiver’s ability to decrypt old out of order messages. This is intended for deployments where many messages may be dropped (e.g. ephemeral messages like typing indicators) but messages are rarely delivered far out of order.<p>Implementors may also clear the state of past KDF Chains by communicating the number of messages sent in the previous epoch, as is done with the Double Ratchet. Specifically they would add the following variables to their state:<ul><li><strong>sending_epoch</strong>: The epoch currently being used to send messages.<li><strong>receiving_epoch</strong>: The latest epoch currently being used to receive messages.<li><strong>PN</strong>: The number of messages sent in the last sending chain, added to the header of every sent message.</ul><p>They implement the following functions:<pre><code>def SealPrevSendingChain(state):
    state.PN = state.kdfchains[state.sending_epoch].send.N
    state.kdfchains[state.sending_epoch].send = None

def SealPrevReceivingChain(state, PN):
    SkipMessageKeys(state, state.receiving_epoch, PN)
    state.kdfchains[state.receiving_epoch].receive = None</code></pre><p>These functions can then be used to clear old state when an epoch advances. Message sending is modified as follows:<pre><code>def SCKARatchetSendKey(state):
    msg, sending_epoch, key_epoch, key = SCKASend(state.scka_state)
    if sending_epoch &gt; state.sending_epoch:
        assert sending_epoch == state.sending_epoch + 1
        SealPrevSendingChain(state)
        state.sending_epoch = sending_epoch
    # remainder of the function is unchanged
    # ...

def SCKARatchetEncrypt(state, plaintext, AD):
    msg, PN, n, mk = SCKARatchetSendKey(state)
    header = SCKA_HEADER(msg, PN, n)
    return header, ENCRYPT(mk, plaintext, CONCAT(AD, header))</code></pre><p>Message receipt is modified similarly:<pre><code>def SCKARatchetReceiveKey(state, header):
    receiving_epoch, key_epoch, key = SCKAReceive(state.scka_state, header.msg)
    if receiving_epoch &gt; state.receiving_epoch:
        assert receiving_epoch == state.receiving_epoch + 1
        SealPrevReceivingChain(state, header.PN)
        state.receiving_epoch = receiving_epoch
    # remainder of the function is unchanged.</code></pre><p>If this approach is used in place of using <em>ClearOldEpochs(state, epoch)</em>, implementors should find some other means to remove old keys from the <em>MKSKIPPED</em> data structure so it does not grow unboundedly.<h1 id="combining-double-ratchets-for-hybrid-security">6. The Triple Ratchet: combining Secure Messaging protocols for hybrid security</h1><p>This section describes the <em>Triple Ratchet</em> protocol.<p>The Double Ratchet provides security guarantees as long as certain Diffie-Hellman assumptions are hard <span class="citation" data-cites="cas2 cas1 ACD19"><a href="#ref-ACD19" role="doc-biblioref">[7]</a>, <a href="#ref-cas2" role="doc-biblioref">[10]</a>, <a href="#ref-cas1" role="doc-biblioref">[11]</a></span>. Similarly, a Sparse Post-Quantum Ratchet based on a quantum-safe SCKA protocol provides post-quantum security guarantees <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[8]</a></span>. In this section we describe how to combine these into a protocol that provides hybrid security: an attacker must break both the elliptic curve and the post-quantum assumptions in order to break the security guarantees of the protocol.<h2 id="overview-2">6.1 Overview</h2><p>The hybridization strategy is simple: run a Double Ratchet and a Sparse Post-Quantum Ratchet in parallel, but only use them to produce <em>message keys</em>, not to perform full encryption or decryption of messages. Now, whenever an encryption key is needed, call each of these Secure Messaging protocols to obtain message keys and then use a KDF to combine these two message keys into an encryption key.<h2 id="state-variables-3">6.2 State variables</h2><p>A Triple Ratchet state consists of a Double Ratchet state and a Sparse Post-Quantum Ratchet state:<ul><li><strong><em>ec_state</em></strong>: the state of an Elliptic Curve Double Ratchet.<li><strong><em>spqr_state</em></strong>: the state of a Sparse Post-Quantum Ratchet.</ul><h2 id="tr-external-functions">6.3 External functions</h2><ul><li><p><strong><em>KDF_HYBRID(ecmk, pqmk)</em></strong>: Returns an AEAD encryption key as the output of applying a KDF keyed by the concatenation of two 32-byte secrets to some unique constant specifying the protocol in use and its parameters.<li><p><strong><em>SCKA_HEADER(scka_msg, pn)</em></strong>: Creates a new message header containing a message output by the SCKA protocol underlying SPQR and the previous chain length <em>pn</em>.</ul><h2 id="tr-initialization">6.4 Initialization</h2><p>Prior to initialization both parties must use some key agreement protocol to agree on 32-byte shared secret keys <em>SKec</em> and <em>SKscka</em>, and Bob’s ratchet public key. These values will be used to initialize the Double Ratchet and the Sparse Post-Quantum Ratchet.<pre><code>def RatchetInitAliceTR(state, SKec, SKscka, bob_dh_public_key):
    RatchetInitAlice(state.ec_state, SKec, bob_dh_public_key)
    RatchetInitSCKA(state.spqr_state, SKscka)

def RatchetInitBobTR(state, SKec, SKscka, bob_dh_key_pair):
    RatchetInitBob(state.ec_state, SKec, bob_dh_key_pair)
    RatchetInitSCKA(state.spqr_state, SKscka)</code></pre><h2 id="encrypting-messages-2">6.5 Encrypting Messages</h2><p>Triple Ratchet messages use a composite header containing:<ul><li><strong>ec_header</strong>: Standard Double Ratchet header (dh, pn, n)<li><strong>scka_header</strong>: SCKA message data and metadata (msg, n)</ul><p>The header structure must ensure both components can be parsed unambiguously.<p>To encrypt a message, get the message keys from both ratchets along with needed header information, then securely combine the two message keys to produce the encryption key.<pre><code>def TripleRatchetEncrypt(state, plaintext, AD):
    ecNs, ec_mk = RatchetSendKey(state.ec_state)
    scka_msg, pqN, pq_mk = SCKARatchetSendKey(state.spqr_state)
    mk = KDF_HYBRID(ec_mk, pq_mk)
    header.ec_header = HEADER(state.ec_state.DHs, state.ec_state.PN, ecNs)
    header.scka_header = SCKA_HEADER(scka_msg, pqN)
    return header, ENCRYPT(mk, plaintext, CONCAT(AD, header))</code></pre><h2 id="decrypting-messages-2">6.6 Decrypting Messages</h2><pre><code>def TripleRatchetDecrypt(state, header, ciphertext, AD):
    ec_mk = RatchetReceiveKey(state.ec_state, header.ec_header)
    pq_mk = SCKARatchetReceiveKey(state.spqr_state, header.scka_header)
    mk = KDF_HYBRID(ec_mk, pq_mk)
    return DECRYPT(mk, ciphertext, CONCAT(AD, header))</code></pre><h1 id="implementation-considerations">7. Implementation considerations</h1><h2 id="integration-with-pqxdh">7.1. Integration with PQXDH</h2><p>All ratchet protocols described in this document - the Double Ratchet, Sparse Post-Quantum Ratchet, and the Triple Ratchet - can be used in combination with the PQXDH key agreement protocol <span class="citation" data-cites="pqxdh"><a href="#ref-pqxdh" role="doc-biblioref">[1]</a></span>. The ratchet protocol plays the role of a “post-PQXDH” protocol which takes the session key <em>SK</em> negotiated by PQXDH and uses it to derive its initial root key(s).<p>The following outputs from PQXDH are used by the ratchet protocols:<ul><li><p>The <em>SK</em> output from PQXDH becomes the <em>SK</em> input to Double Ratchet initialization (see <a href="#dr-initialization">Section 3.3</a>) or Sparse Post-Quantum Ratchet initialization (see <a href="#spqr-initialization">Section 5.4</a>). For the Triple Ratchet the <em>SK</em> output from PQXDH should be expanded into two 32-byte keys <em>SKec</em> and <em>SKscka</em> using a key derivation function and used as input for the Triple Ratchet initialization (see <a href="#tr-initialization">Section 6.4</a>).<li><p>The <em>AD</em> output from PQXDH becomes the <em>AD</em> input to ratchet protocol encryption and decryption (see <a href="#dr-encrypting-messages">Section 3.4</a> and <a href="#dr-decrypting-messages">Section 3.5</a>).<li><p>Bob’s signed prekey from PQXDH (<em>SPK<sub>B</sub></em>) becomes Bob’s initial ratchet public key (and corresponding key pair) for Double Ratchet initialization.</ul><p>Any message encrypted using Alice’s initial ratchet protocol state before any messages have been received can serve as an “initial ciphertext” for PQXDH. To deal with the possibility of lost or out-of-order messages, a recommended pattern is for Alice to repeatedly send the same PQXDH initial message prepended to all of her ratchet protocol messages until she receives Bob’s first ratchet protocol response message.<h2 id="recommended-cryptographic-algorithms">7.2. Recommended cryptographic algorithms</h2><p>The following choices are recommended for instantiating the cryptographic functions from <a href="#dr-external-functions">Section 3.1</a>, <a href="#spqr-external-functions">Section 5.2</a>, and <a href="#tr-external-functions">Section 6.3</a>. Functions used for the Sparse Post-Quantum Ratchet and the Triple Ratchet respectively depend on constant strings <em>SPQR_PROTOCOL_INFO</em> and <em>TR_PROTOCOL_INFO</em> that should uniquely identify the protocol and version in use.<ul><li><p><strong><em>GENERATE_DH()</em></strong>: This function is recommended to generate a key pair based on the Curve25519 or Curve448 elliptic curves <span class="citation" data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[12]</a></span>.<li><p><strong><em>DH(dh_pair, dh_pub)</em></strong>: This function is recommended to return the output from the X25519 or X448 function as defined in <span class="citation" data-cites="rfc7748"><a href="#ref-rfc7748" role="doc-biblioref">[12]</a></span>. There is no need to check for invalid public keys.<li><p><strong><em>KDF_RK(rk, dh_out)</em></strong>: This function is recommended to be implemented using HKDF <span class="citation" data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[3]</a></span> with SHA-256 or SHA-512 <span class="citation" data-cites="nistsha2"><a href="#ref-nistsha2" role="doc-biblioref">[13]</a></span> and: using <em>rk</em> as HKDF <em>salt</em>, <em>dh_out</em> as HKDF <em>input key material</em>, and an application-specific byte sequence as HKDF <em>info</em>. The <em>info</em> value should be chosen to be distinct from other uses of HKDF in the application.<li><p><strong><em>KDF_CK(ck)</em></strong>: HMAC <span class="citation" data-cites="rfc2104"><a href="#ref-rfc2104" role="doc-biblioref">[2]</a></span> with SHA-256 or SHA-512 <span class="citation" data-cites="nistsha2"><a href="#ref-nistsha2" role="doc-biblioref">[13]</a></span> is recommended, using <em>ck</em> as the HMAC key and using separate constants as input (e.g. a single byte 0x01 as input to produce the message key, and a single byte 0x02 as input to produce the next chain key). If <em>ck</em> is <em>None</em> this function must fail in a way that terminates processing.<li><p><strong><em>ENCRYPT(mk, plaintext, associated_data)</em></strong>: This function is recommended to be implemented with an AEAD encryption scheme based on either SIV or a composition of CBC with HMAC <span class="citation" data-cites="aead siv"><a href="#ref-aead" role="doc-biblioref">[5]</a>, <a href="#ref-siv" role="doc-biblioref">[14]</a></span>. These schemes provide some misuse-resistance in case a key is mistakenly used multiple times. A concrete recommendation based on CBC and HMAC is as follows:<ul><li><p>HKDF is used with SHA-256 or SHA-512 to generate 80 bytes of output. The HKDF <em>salt</em> is set to a zero-filled byte sequence equal to the hash’s output length. HKDF <em>input key material</em> is set to <em>mk</em>. HKDF <em>info</em> is set to an application-specific byte sequence distinct from other uses of HKDF in the application.<ul><li><p>The HKDF output is divided into a 32-byte encryption key, a 32-byte authentication key, and a 16-byte IV.<li><p>The plaintext is encrypted using AES-256 in CBC mode with PKCS#7 padding, using the encryption key and IV from the previous step <span class="citation" data-cites="nistaes rfc2315"><a href="#ref-nistaes" role="doc-biblioref">[15]</a>, <a href="#ref-rfc2315" role="doc-biblioref">[16]</a></span>.<li><p>HMAC is calculated using the authentication key and the same hash function as above <span class="citation" data-cites="rfc2104"><a href="#ref-rfc2104" role="doc-biblioref">[2]</a></span>. The HMAC input is the <em>associated_data</em> prepended to the ciphertext. The HMAC output is appended to the ciphertext.</ul></ul><li><p><strong><em>SCKA</em></strong>: For hybrid post-quantum security, this protocol is recommended to be the ML-KEM Braid protocol described in <span class="citation" data-cites="mlkembraid"><a href="#ref-mlkembraid" role="doc-biblioref">[9]</a></span>.<li><p><strong><em>KDF_SCKA_INIT(sk)</em></strong> This function is recommended to be implemented using HKDF <span class="citation" data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[3]</a></span> with SHA-256 or SHA-512 <span class="citation" data-cites="nistsha2"><a href="#ref-nistsha2" role="doc-biblioref">[13]</a></span> and:<ul><li><strong>salt</strong>: zero-filled 32 bytes<li><strong>ikm</strong>: <em>sk</em><li><strong>info</strong>: Some unique constant specifying the protocol and version, followed by “Chain Start”<li><strong>length</strong>: 96</ul><li><p><strong><em>KDF_SCKA_RK(rk, scka_out)</em></strong>: This function is recommended to be implemented using HKDF <span class="citation" data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[3]</a></span> with SHA-256 or SHA-512 <span class="citation" data-cites="nistsha2"><a href="#ref-nistsha2" role="doc-biblioref">[13]</a></span> and:<ul><li><strong>salt</strong>: <em>rk</em><li><strong>ikm</strong>: <em>scka_output</em><li><strong>info</strong>: <em>SPQR_PROTOCOL_INFO</em> followed by “Chain Add Epoch”<li><strong>length</strong>: 96</ul><li><p><strong><em>KDF_SCKA_CK(ck, ctr)</em></strong>: This function is recommended to be implemented using HKDF <span class="citation" data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[3]</a></span> with SHA-256 or SHA-512 <span class="citation" data-cites="nistsha2"><a href="#ref-nistsha2" role="doc-biblioref">[13]</a></span> and:<ul><li><strong>salt</strong>: zero-filled 32 bytes<li><strong>ikm</strong>: <em>sk</em><li><strong>info</strong>: <em>SPQR_PROTOCOL_INFO</em> followed by “Chain Start”<li><strong>length</strong>: 64</ul><li><p><strong><em>KDF_HYBRID(ec_mk, scka_mk)</em></strong>: This function is recommended to be implemented using HKDF <span class="citation" data-cites="rfc5869"><a href="#ref-rfc5869" role="doc-biblioref">[3]</a></span> with SHA-256 or SHA-512 <span class="citation" data-cites="nistsha2"><a href="#ref-nistsha2" role="doc-biblioref">[13]</a></span> and:<ul><li><strong>salt</strong>: <em>scka_mk</em><li><strong>ikm</strong>: <em>ec_mk</em><li><strong>info</strong>: <em>TR_PROTOCOL_INFO</em><li><strong>length</strong>: Key length required by <em>AEAD</em>.</ul></ul><h1 id="security-considerations">8. Security considerations</h1><h2 id="secure-deletion">8.1. Secure deletion</h2><p>These ratchet protocols are designed to provide security against an attacker who records encrypted messages and then compromises the sender or receiver at a later time. This security could be defeated if deleted plaintext or keys could be recovered by an attacker with low-level access to the compromised device. Recovering deleted data from storage media is a complicated topic which is outside the scope of this document.<h2 id="recovery-from-compromise">8.2. Recovery from compromise</h2><p>These ratchet protocols are designed to recover security against a passive eavesdropper who observes encrypted messages after compromising one (or both) of the parties to a session. Despite this mitigation, a compromise of secret keys or of device integrity will have a devastating effect on the security of future communications. For example:<ul><li><p>The attacker could use the compromised keys to impersonate the compromised party (e.g. using the compromised party’s identity private key with PQXDH to create new sessions).<li><p>The attacker could substitute her own ratchet keys via continuous active man-in-the-middle attack, to maintain eavesdropping on the compromised session.<li><p>The attacker could modify a compromised party’s RNG so that future ratchet private keys are predictable.</ul><p>If a party suspects its keys or devices have been compromised, it must replace them immediately.<h2 id="cryptanalysis-and-ratchet-public-keys">8.3. Cryptanalysis and ratchet public keys</h2><p>Because all DH ratchet computations and SCKA secrets are mixed into the root key, an attacker who can decrypt a session with passive cryptanalysis might lose this ability if she fails to observe some ratchet public key.<p>This is not a reliable countermeasure against cryptanalysis, of course. If weaknesses are discovered in any of the cryptographic algorithms a session relies upon, the session should be discarded and replaced with a new session using strong cryptography.<h2 id="deletion-of-skipped-message-keys">8.4. Deletion of skipped message keys</h2><p>Storing skipped message keys introduces some risks:<ul><li><p>A malicious sender could induce recipients to store large numbers of skipped message keys, possibly causing denial-of-service due to consuming storage space.<li><p>The lost messages may have been seen (and recorded) by an attacker, even though they didn’t reach the recipient. The attacker can compromise the intended recipient at a later time to retrieve the skipped message keys.</ul><p>To mitigate the first risk parties should set reasonable per-session limits on the number of skipped message keys that will be stored (e.g. 1000). To mitigate the second risk parties should delete skipped message keys after an appropriate interval. Deletion could be triggered by a timer, or by counting a number of events (messages received, DH ratchet steps, etc.).<h2 id="deferring-new-ratchet-key-generation">8.5. Deferring new ratchet key generation</h2><p>During each DH ratchet step a new ratchet key pair and sending chain are generated. As the sending chain is not needed right away, these steps could be deferred until the party is about to send a new message. This would slightly increase security by shortening the lifetime of ratchet keys, at the cost of some complexity.<h2 id="truncating-authentication-tags">8.6. Truncating authentication tags</h2><p>If the <em>ENCRYPT()</em> function is implemented using CBC and HMAC as described in <a href="#recommended-cryptographic-algorithms">Section 7.2</a>, then truncating the final HMAC output to 128 bits to reduce message size is acceptable. Truncating it further might be acceptable, though requires careful analysis. In no case should the final HMAC be truncated to less than 64 bits.<p>If the <em>ENCRYPT()</em> function is implemented differently, then truncation might require a more complicated analysis and is not recommended.<h2 id="implementation-fingerprinting">8.7. Implementation fingerprinting</h2><p>If this protocol is used in settings with anonymous parties, care should be taken that implementations behave identically in all cases.<p>In an anonymous context, implementations are advised to follow the algorithms from Sections 3 and 4 precisely. Such implementations are also advised to use identical limits for the number of skipped message keys stored, and identical deletion policies for skipped message keys. Deletion policies should be based on deterministic events (e.g. messages received), rather than time.<h2 id="choice-of-scka-protocol">8.8 Choice of SCKA protocol</h2><p>The Triple Ratchet described in <a href="#combining-double-ratchets-for-hybrid-security">Section 6</a> was proposed in <span class="citation" data-cites="tripleratchet"><a href="#ref-tripleratchet" role="doc-biblioref">[17]</a></span> where it is proven to provide <em>hybrid</em> security. It does not weaken the security guarantees of the Double Ratchet and it adds PCS and FS guarantees provided by the SCKA. The ML-KEM Braid Protocol <span class="citation" data-cites="mlkembraid"><a href="#ref-mlkembraid" role="doc-biblioref">[9]</a></span>, for example, provides FS and will provide Module LWE-based PCS healing for messages after two SCKA output keys are mixed into the ratchet.<p>As discussed in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[8]</a></span>, the PCS of SCKA protocols should be compared by looking at the number of messages in the “Vulnerable Message set” - the set of messages exposed to an attacker who compromises a user device. This can vary considerably depending on messaging behavior and on the way the SCKA protocol generates and manages secrets internally. We recommend the ML-KEM Braid protocol because it uses a standardized KEM and it has a small Vulnerable Message Set across a wide range of message sending behaviors. Applications with very specific message sending patterns - e.g. applications where devices are rarely online at the same time and send large numbers of messages without receiving responses - may find that a different SCKA protocol provides better security.<h2 id="effect-of-dropped-messages-on-pcs">8.9 Effect of dropped messages on PCS</h2><p>These ratchet protocols are all designed for <em>immediate decryption</em>: they can tolerate dropped or out of order messages. Note, though, that for the Sparse Post-Quantum Ratchet dropped messages may slow down the progress of the public ratchet and hence degrade PCS. This does not happen with the classical Double Ratchet.<h2 id="deletion-of-old-kdf-chain-state">8.10 Deletion of old KDF Chain state</h2><p>The Sparse Post-Quantum Ratchet offered an alternative mechanism for clearing past KDF Chain state in <a href="#spqr-clearing-past-epoch-state">Section 5.7</a>. Using this alternative does provide a security benefit, since it deletes sending chain keys as soon as they are not needed and it deletes receiving chain keys as soon as a message is received in a later epoch. An example of the security consequences of this difference can be found in Appendix A.1 of <span class="citation" data-cites="cjn23"><a href="#ref-cjn23" role="doc-biblioref">[18]</a></span>.<h2 id="harvest-now-decrypt-later-attacks">8.11 Harvest Now, Decrypt Later Attacks</h2><p>The primary motivation for introducing post-quantum ratcheting today is protection against adversaries who compromise devices today, record encrypted communications, and wait for cryptographically relevant quantum computers. Against such adversaries, classical Double Ratchet healing provides no protection—all recorded messages remain vulnerable regardless of subsequent Diffie-Hellman based key rotation.<h1 id="ipr">9. IPR</h1><p>This document is hereby placed in the public domain.<h1 id="acknowledgements">10. Acknowledgements</h1><p>The Double Ratchet algorithm was designed by Trevor Perrin and Moxie Marlinspike.<p>The concept of a Diffie-Hellman ratchet was taken from the OTR protocol by Nikita Borisov, Ian Goldberg, and Eric Brewer <span class="citation" data-cites="otr"><a href="#ref-otr" role="doc-biblioref">[19]</a></span>.<p>Symmetric-key ratcheting is an old idea <span class="citation" data-cites="abdallah scicrypt"><a href="#ref-abdallah" role="doc-biblioref">[20]</a>, <a href="#ref-scicrypt" role="doc-biblioref">[21]</a></span>. It’s been used in recent protocols like SCIMP and MinimaLT <span class="citation" data-cites="scimp1 scimp2 minimalt"><a href="#ref-scimp1" role="doc-biblioref">[22]</a>–<a href="#ref-minimalt" role="doc-biblioref">[24]</a></span>.<p>The term “ratchet” for forward-secure key updating was introduced by Adam Langley in Pond <span class="citation" data-cites="pond"><a href="#ref-pond" role="doc-biblioref">[25]</a></span>.<p>Thanks to Michael Rogers and Adam Back for mailing list discussions <span class="citation" data-cites="randombit"><a href="#ref-randombit" role="doc-biblioref">[26]</a></span>.<p>Thanks to Adam Langley for discussion on improving the receiving algorithm.<p>The security of this protocol and similar protocols has been analyzed by Katriel Cohn-Gordon, Cas Cremers, Benjamin Dowling, Luke Garratt, and Douglas Stebila <span class="citation" data-cites="cas2 cas1"><a href="#ref-cas2" role="doc-biblioref">[10]</a>, <a href="#ref-cas1" role="doc-biblioref">[11]</a></span>.<p>Thanks to Tom Ritter, Joseph Bonneau, Ximin Luo, Yan Zhu, Samuel Neves, Raphael Arias, and David J. Wu for editorial feedback.<p><strong>Post-Quantum Extensions</strong><p>The post-quantum extensions - the Triple Ratchet, SPQR, and the ML-KEM Braid - were designed by Graeme Connell and Rolfe Schmidt.<p>The construction of secure messaging from a Sparse Continuous Key Agreement protocol was introduced and analyzed in <span class="citation" data-cites="comparesm"><a href="#ref-comparesm" role="doc-biblioref">[8]</a></span>. The hybridization technique used to construct the Triple Ratchet was introduced and analyzed in <span class="citation" data-cites="tripleratchet"><a href="#ref-tripleratchet" role="doc-biblioref">[17]</a></span>. The authors of these papers, Benedikt Auerbach, Yevgeniy Dodis, Daniel Jost, Shuichi Katsumata, and Thomas Prest contributed protocol design, analysis, and editorial feedback.<p>Karthik Bhargavan and Franziskus Kiefer were involved throughout the implementation process and contributed to the detailed design, modeling and analysis of SPQR using ProVerif, and editorial feedback on this documentation.<p>Thanks to Rune Fiedler, Charlie Jacomme, and Nadim Kobeissi for valuable editorial feedback.<p>This work builds on the firm foundation the cryptography research community has created for us, and we deeply appreciate their continued efforts to improve our understanding of secure communication.<h1 class="unnumbered" id="references">9. References</h1><div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list"><div id="ref-pqxdh" class="csl-entry" role="listitem"><div class="csl-left-margin">[1]</div><div class="csl-right-inline">E. Kret and R. Schmidt, <span>“The PQXDH key agreement protocol,”</span> 2023. <a href="https://signal.org/docs/specifications/pqxdh/">https://signal.org/docs/specifications/pqxdh/</a></div></div><div id="ref-rfc2104" class="csl-entry" role="listitem"><div class="csl-left-margin">[2]</div><div class="csl-right-inline">H. Krawczyk, M. Bellare, and R. Canetti, <span>“<span class="nocase">HMAC: Keyed-Hashing for Message Authentication</span>.”</span> Internet Engineering Task Force; RFC 2104 (Informational); IETF, Feb-1997. <a href="http://www.ietf.org/rfc/rfc2104.txt">http://www.ietf.org/rfc/rfc2104.txt</a></div></div><div id="ref-rfc5869" class="csl-entry" role="listitem"><div class="csl-left-margin">[3]</div><div class="csl-right-inline">H. Krawczyk and P. Eronen, <span>“<span class="nocase">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</span>.”</span> Internet Engineering Task Force; RFC 5869 (Informational); IETF, May-2010. <a href="http://www.ietf.org/rfc/rfc5869.txt">http://www.ietf.org/rfc/rfc5869.txt</a></div></div><div id="ref-barakhalevi" class="csl-entry" role="listitem"><div class="csl-left-margin">[4]</div><div class="csl-right-inline">B. Barak and S. Halevi, <span>“<span class="nocase">A model and architecture for pseudo-random generation with applications to /dev/random</span>.”</span> Cryptology ePrint Archive, Report 2005/029, 2005. <a href="http://eprint.iacr.org/2005/029">http://eprint.iacr.org/2005/029</a></div></div><div id="ref-aead" class="csl-entry" role="listitem"><div class="csl-left-margin">[5]</div><div class="csl-right-inline">P. Rogaway, <span>“<span class="nocase">Authenticated-encryption with Associated-data</span>,”</span> in <span class="nocase">Proceedings of the 9th <span>ACM</span> Conference on Computer and Communications Security</span>, 2002. <a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf">http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf</a></div></div><div id="ref-pond2" class="csl-entry" role="listitem"><div class="csl-left-margin">[6]</div><div class="csl-right-inline">A. Langley, <span>“<span>Pond</span>,”</span> 2012. <a href="https://github.com/agl/pond">https://github.com/agl/pond</a></div></div><div id="ref-ACD19" class="csl-entry" role="listitem"><div class="csl-left-margin">[7]</div><div class="csl-right-inline">J. Alwen, S. Coretti, and Y. Dodis, <span>“The double ratchet: Security notions, proofs, and modularization for the signal protocol,”</span> in Advances in cryptology - <span>EUROCRYPT</span> 2019 - 38th annual international conference on the theory and applications of cryptographic techniques, darmstadt, germany, may 19-23, 2019, proceedings, part <span>I</span>, 2019, vol. 11476. <a href="https://doi.org/10.1007/978-3-030-17653-2\_5">https://doi.org/10.1007/978-3-030-17653-2\_5</a></div></div><div id="ref-comparesm" class="csl-entry" role="listitem"><div class="csl-left-margin">[8]</div><div class="csl-right-inline">B. Auerbach, Y. Dodis, D. Jost, S. Katsumata, and R. Schmidt, <span>“How to compare two-party secure messaging protocols: A quest for a more efficient and secure post-quantum protocol,”</span> 2025.</div></div><div id="ref-mlkembraid" class="csl-entry" role="listitem"><div class="csl-left-margin">[9]</div><div class="csl-right-inline">S. Research, <span>“The ML-KEM braid protocol,”</span> 2025. <a href="https://signal.org/docs/specifications/mlkembraid/">https://signal.org/docs/specifications/mlkembraid/</a></div></div><div id="ref-cas2" class="csl-entry" role="listitem"><div class="csl-left-margin">[10]</div><div class="csl-right-inline">K. Cohn-Gordon, C. Cremers, B. Dowling, L. Garratt, and D. Stebila, <span>“<span class="nocase">A Formal Security Analysis of the Signal Messaging Protocol</span>.”</span> Cryptology ePrint Archive, Report 2016/1013, 2016. <a href="http://eprint.iacr.org/2016/1013">http://eprint.iacr.org/2016/1013</a></div></div><div id="ref-cas1" class="csl-entry" role="listitem"><div class="csl-left-margin">[11]</div><div class="csl-right-inline">K. Cohn-Gordon, C. Cremers, and L. Garratt, <span>“<span>On Post-Compromise Security</span>.”</span> Cryptology ePrint Archive, Report 2016/221, 2016. <a href="http://eprint.iacr.org/2016/221">http://eprint.iacr.org/2016/221</a></div></div><div id="ref-rfc7748" class="csl-entry" role="listitem"><div class="csl-left-margin">[12]</div><div class="csl-right-inline">A. Langley, M. Hamburg, and S. Turner, <span>“<span class="nocase">Elliptic Curves for Security</span>.”</span> Internet Engineering Task Force; RFC 7748 (Informational); IETF, Jan-2016. <a href="http://www.ietf.org/rfc/rfc7748.txt">http://www.ietf.org/rfc/rfc7748.txt</a></div></div><div id="ref-nistsha2" class="csl-entry" role="listitem"><div class="csl-left-margin">[13]</div><div class="csl-right-inline">NIST, <span>“<span>FIPS 180-4. Secure Hash Standard (SHS)</span>,”</span> National Institute of Standards &amp; Technology, Gaithersburg, MD, United States, 2012. <a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf</a></div></div><div id="ref-siv" class="csl-entry" role="listitem"><div class="csl-left-margin">[14]</div><div class="csl-right-inline">P. Rogaway and T. Shrimpton, <span>“<span class="nocase">A Provable-security Treatment of the Key-wrap Problem</span>,”</span> in <span class="nocase">Proceedings of the 24th Annual International Conference on The Theory and Applications of Cryptographic Techniques</span>, 2006. <a href="http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.html">http://web.cs.ucdavis.edu/~rogaway/papers/keywrap.html</a></div></div><div id="ref-nistaes" class="csl-entry" role="listitem"><div class="csl-left-margin">[15]</div><div class="csl-right-inline">NIST, <span>“<span>FIPS 197. Advanced Encryption Standard</span>,”</span> National Institute of Standards &amp; Technology, Gaithersburg, MD, United States, 2001. <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf</a></div></div><div id="ref-rfc2315" class="csl-entry" role="listitem"><div class="csl-left-margin">[16]</div><div class="csl-right-inline">B. Kaliski, <span>“<span>PKCS #7: Cryptographic Message Syntax Version 1.5</span>.”</span> Internet Engineering Task Force; RFC 2315 (Informational); IETF, Mar-1998. <a href="http://www.ietf.org/rfc/rfc2315.txt">http://www.ietf.org/rfc/rfc2315.txt</a></div></div><div id="ref-tripleratchet" class="csl-entry" role="listitem"><div class="csl-left-margin">[17]</div><div class="csl-right-inline">Y. Dodis, D. Jost, S. Katsumata, T. Prest, and R. Schmidt, <span>“Triple ratchet: A bandwidth efficient hybrid-secure signal protocol.”</span> Cryptology <span>ePrint</span> Archive, Paper 2025/078, 2025. <a href="https://eprint.iacr.org/2025/078">https://eprint.iacr.org/2025/078</a></div></div><div id="ref-cjn23" class="csl-entry" role="listitem"><div class="csl-left-margin">[18]</div><div class="csl-right-inline">C. Cremers, C. Jacomme, and A. Naska, <span>“Formal analysis of <span>Session-Handling</span> in secure messaging: Lifting security from sessions to conversations,”</span> in 32nd USENIX security symposium (USENIX security 23), 2023. <a href="https://www.usenix.org/conference/usenixsecurity23/presentation/cremers-session-handling">https://www.usenix.org/conference/usenixsecurity23/presentation/cremers-session-handling</a></div></div><div id="ref-otr" class="csl-entry" role="listitem"><div class="csl-left-margin">[19]</div><div class="csl-right-inline">N. Borisov, I. Goldberg, and E. Brewer, <span>“<span class="nocase">Off-the-record Communication, or, Why Not to Use PGP</span>,”</span> in Proceedings of the 2004 ACM workshop on privacy in the electronic society, 2004. <a href="https://otr.cypherpunks.ca/otr-wpes.pdf">https://otr.cypherpunks.ca/otr-wpes.pdf</a></div></div><div id="ref-abdallah" class="csl-entry" role="listitem"><div class="csl-left-margin">[20]</div><div class="csl-right-inline">M. Abdalla and M. Bellare, <span>“<span class="nocase">Increasing the Lifetime of a Key: A Comparative Analysis of the Security of Re-keying Techniques</span>,”</span> in <span class="nocase">Advances in Cryptology - ASIACRYPT 2000, 6th International Conference on the Theory and Application of Cryptology and Information Security</span>, 2000. <a href="https://cseweb.ucsd.edu/~mihir/papers/rekey.html">https://cseweb.ucsd.edu/~mihir/papers/rekey.html</a></div></div><div id="ref-scicrypt" class="csl-entry" role="listitem"><div class="csl-left-margin">[21]</div><div class="csl-right-inline">B. Olson, <span>“<span class="nocase">Key Coercion after encrypted message transmission</span>.”</span> sci.crypt, 1994. <a href="https://groups.google.com/d/topic/sci.crypt/3MJzGwiTZ10/discussion">https://groups.google.com/d/topic/sci.crypt/3MJzGwiTZ10/discussion</a></div></div><div id="ref-scimp1" class="csl-entry" role="listitem"><div class="csl-left-margin">[22]</div><div class="csl-right-inline">Wikipedia, <span>“<span>Silent Circle Instant Messaging Protocol — Wikipedia<span>,</span> The Free Encyclopedia</span>.”</span> 2016. <a href="https://en.wikipedia.org/w/index.php?title=Silent_Circle_Instant_Messaging_Protocol">https://en.wikipedia.org/w/index.php?title=Silent_Circle_Instant_Messaging_Protocol</a></div></div><div id="ref-scimp2" class="csl-entry" role="listitem"><div class="csl-left-margin">[23]</div><div class="csl-right-inline">G. Belvin, <span>“<span>A Secure Text Messaging Protocol</span>.”</span> Cryptology ePrint Archive, Report 2014/036, 2014. <a href="http://eprint.iacr.org/2014/036">http://eprint.iacr.org/2014/036</a></div></div><div id="ref-minimalt" class="csl-entry" role="listitem"><div class="csl-left-margin">[24]</div><div class="csl-right-inline">W. M. Petullo, X. Zhang, J. A. Solworth, D. J. Bernstein, and T. Lange, <span>“<span class="nocase">MinimaLT: Minimal-latency Networking Through Better Security</span>,”</span> in <span class="nocase">Proceedings of the 2013 ACM SIGSAC Conference on Computer &amp; Communications Security</span>, 2013. <a href="http://doi.acm.org/10.1145/2508859.2516737">http://doi.acm.org/10.1145/2508859.2516737</a></div></div><div id="ref-pond" class="csl-entry" role="listitem"><div class="csl-left-margin">[25]</div><div class="csl-right-inline">A. Langley, <span>“<span class="nocase">Pond/README.md</span>,”</span> 2012. <a href="https://github.com/agl/pond/commit/7bb06244b9aa121d367a6d556867992d1481f0c8">https://github.com/agl/pond/commit/7bb06244b9aa121d367a6d556867992d1481f0c8</a></div></div><div id="ref-randombit" class="csl-entry" role="listitem"><div class="csl-left-margin">[26]</div><div class="csl-right-inline">M. Rogers and A. Back, <span>“<span class="nocase">Asynchronous forward secrecy encryption</span>.”</span> Cryptography mailing list, 2013. <a href="http://lists.randombit.net/pipermail/cryptography/2013-September/005327.html">http://lists.randombit.net/pipermail/cryptography/2013-September/005327.html</a></div></div></div></div></div><div class="columns is-centered"><div class="column is-3"></div><div class="column is-6"><h3>Want to get involved with Signal? <a href="/workworkwork/">We're hiring!</a></h3></div><div class="column is-3"></div></div></div></article></section><footer class="footer"><div class="container"><div class="columns"><div class="column is-two-fifths is-hidden-mobile"> <span class="copyright">&copy; 2013&ndash;2026 Signal, a 501c3 nonprofit.</span><br /> "Signal", Signal logos, and other trademarks are trademarks or registered trademarks of Signal Technology Foundation in the United States and other countries (<a href="/brand/">more info here</a>). <br /> <br /> For media inquiries, contact <a href="/cdn-cgi/l/email-protection#7e0e0c1b0d0d3e0d1719101f1250110c19"><span class="__cf_email__" data-cfemail="8cfcfee9ffffccffe5ebe2ede0a2e3feeb">[email&#160;protected]</span></a></div><div class="column"> <strong>Organization</strong><ul><li> <a href="/donate/">Donate</a><li> <a href="/workworkwork/">Careers</a><li> <a href="/blog/">Blog</a><li> <a href="/brand/">Brand Assets</a><li> <a href="/legal/">Terms &amp; Privacy Policy</a></ul></div><div class="column"> <strong>Download</strong><ul><li> <a href="/download/android/">Android</a><li> <a href="/download/ios/">iPhone & iPad</a><li> <a href="/download/windows/">Windows</a><li> <a href="/download/macos/">Mac</a><li> <a href="/download/linux/">Linux</a></ul></div><div class="column"> <strong>Social</strong><ul><li> <a href="https://bsky.app/profile/signal.org" target="_blank">Bluesky</a><li> <a href="https://github.com/signalapp" target="_blank">GitHub</a><li> <a href="https://www.instagram.com/signal_app/" target="_blank">Instagram</a><li> <a href="https://mastodon.world/@signalapp" target="_blank">Mastodon</a><li> <a href="https://x.com/signalapp" target="_blank">X</a></ul></div><div class="column"> <strong>Help</strong><ul><li> <a href="https://support.signal.org">Support Center</a><li> <a href="https://community.signalusers.org/">Community</a></ul></div><div class="column is-two-fifths is-hidden-tablet"> <span class="copyright">&copy; 2013&ndash;2026 Signal, a 501c3 nonprofit.</span><br /> "Signal", Signal logos, and other trademarks are trademarks or registered trademarks of Signal Technology Foundation in the United States and other countries (<a href="/brand/">more info here</a>). <br /> <br /> For media inquiries, contact <a href="/cdn-cgi/l/email-protection#4f3f3d2a3c3c0f3c2628212e2361203d28"><span class="__cf_email__" data-cfemail="017173647272417268666f606d2f6e7366">[email&#160;protected]</span></a></div></div></div></footer><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript" src="/assets/javascripts/vendor/jquery-3.7.1.min.js"></script> <script type="text/javascript" src="/assets/javascripts/vendor/lottie-player-2.0.3.min.js"></script> <script type="text/javascript"> document.addEventListener('DOMContentLoaded', () => { var userAgent = navigator.userAgent.toLowerCase(); var isIOS = ( userAgent.indexOf('iphone') !== -1 || userAgent.indexOf('ipad') !== -1 || userAgent.indexOf('ipod') !== -1 ); var isAndroid = userAgent.indexOf('android') !== -1; var $downloadSignal = $('.get-signal'); if (isIOS || isAndroid) { var url = isIOS ? 'https://apps.apple.com/us/app/signal-private-messenger/id874139669' : 'https://play.google.com/store/apps/details?id=org.thoughtcrime.securesms'; $downloadSignal.prop('href', url); $downloadSignal.html('<span>Get Signal</span> <i class="icon icon-external-link-alt"></i>'); } const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger')); if ($navbarBurgers.length > 0) { $navbarBurgers.forEach((el) => { el.addEventListener('click', () => { const target = el.dataset.target; const $target = document.getElementById(target); el.classList.toggle('is-active'); $target.classList.toggle('is-active'); }); }); } }); </script>
